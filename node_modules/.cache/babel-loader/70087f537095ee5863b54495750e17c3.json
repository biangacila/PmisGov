{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], t) : \"object\" == typeof exports ? exports[\"react-hls\"] = t(require(\"react\")) : e[\"react-hls\"] = t(e.react);\n}(this, function (e) {\n  return function (e) {\n    function t(i) {\n      if (r[i]) return r[i].exports;\n      var a = r[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(a.exports, a, a.exports, t), a.l = !0, a.exports;\n    }\n\n    var r = {};\n    return t.m = e, t.c = r, t.i = function (e) {\n      return e;\n    }, t.d = function (e, r, i) {\n      t.o(e, r) || Object.defineProperty(e, r, {\n        configurable: !1,\n        enumerable: !0,\n        get: i\n      });\n    }, t.n = function (e) {\n      var r = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return t.d(r, \"a\", r), r;\n    }, t.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, t.p = \"\", t(t.s = 32);\n  }({\n    0: function _(e, t, r) {\n      \"use strict\";\n\n      function i(e, t, r, i, n, s, o, l) {\n        if (a(t), !e) {\n          var u;\n          if (void 0 === t) u = Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");else {\n            var d = [r, i, n, s, o, l],\n                f = 0;\n            u = Error(t.replace(/%s/g, function () {\n              return d[f++];\n            })), u.name = \"Invariant Violation\";\n          }\n          throw u.framesToPop = 1, u;\n        }\n      }\n\n      var a = function a(e) {};\n\n      e.exports = i;\n    },\n    17: function _(t, r) {\n      t.exports = e;\n    },\n    24: function _(e, t, r) {\n      \"use strict\";\n\n      var i = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n      e.exports = i;\n    },\n    30: function _(e, t, r) {\n      var i, i;\n      !function (t) {\n        e.exports = t();\n      }(function () {\n        var e;\n        return function e(t, r, a) {\n          function n(o, l) {\n            if (!r[o]) {\n              if (!t[o]) {\n                var u = \"function\" == typeof i && i;\n                if (!l && u) return i(o, !0);\n                if (s) return s(o, !0);\n                var d = Error(\"Cannot find module '\" + o + \"'\");\n                throw d.code = \"MODULE_NOT_FOUND\", d;\n              }\n\n              var f = r[o] = {\n                exports: {}\n              };\n              t[o][0].call(f.exports, function (e) {\n                var r = t[o][1][e];\n                return n(r ? r : e);\n              }, f, f.exports, e, t, r, a);\n            }\n\n            return r[o].exports;\n          }\n\n          for (var s = \"function\" == typeof i && i, o = 0; a.length > o; o++) {\n            n(a[o]);\n          }\n\n          return n;\n        }({\n          1: [function (e, t, r) {\n            function i() {\n              this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;\n            }\n\n            function a(e) {\n              return \"function\" == typeof e;\n            }\n\n            function n(e) {\n              return \"number\" == typeof e;\n            }\n\n            function s(e) {\n              return \"object\" == typeof e && null !== e;\n            }\n\n            function o(e) {\n              return void 0 === e;\n            }\n\n            t.exports = i, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._maxListeners = void 0, i.defaultMaxListeners = 10, i.prototype.setMaxListeners = function (e) {\n              if (!n(e) || 0 > e || isNaN(e)) throw TypeError(\"n must be a positive number\");\n              return this._maxListeners = e, this;\n            }, i.prototype.emit = function (e) {\n              var t, r, i, n, l, u;\n\n              if (this._events || (this._events = {}), \"error\" === e && (!this._events.error || s(this._events.error) && !this._events.error.length)) {\n                if (t = arguments[1], t instanceof Error) throw t;\n                var d = Error('Uncaught, unspecified \"error\" event. (' + t + \")\");\n                throw d.context = t, d;\n              }\n\n              if (r = this._events[e], o(r)) return !1;\n              if (a(r)) switch (arguments.length) {\n                case 1:\n                  r.call(this);\n                  break;\n\n                case 2:\n                  r.call(this, arguments[1]);\n                  break;\n\n                case 3:\n                  r.call(this, arguments[1], arguments[2]);\n                  break;\n\n                default:\n                  n = Array.prototype.slice.call(arguments, 1), r.apply(this, n);\n              } else if (s(r)) for (n = Array.prototype.slice.call(arguments, 1), u = r.slice(), i = u.length, l = 0; i > l; l++) {\n                u[l].apply(this, n);\n              }\n              return !0;\n            }, i.prototype.addListener = function (e, t) {\n              var r;\n              if (!a(t)) throw TypeError(\"listener must be a function\");\n              return this._events || (this._events = {}), this._events.newListener && this.emit(\"newListener\", e, a(t.listener) ? t.listener : t), this._events[e] ? s(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, s(this._events[e]) && !this._events[e].warned && (r = o(this._maxListeners) ? i.defaultMaxListeners : this._maxListeners, r && r > 0 && this._events[e].length > r && (this._events[e].warned = !0, console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\", this._events[e].length), \"function\" == typeof console.trace && console.trace())), this;\n            }, i.prototype.on = i.prototype.addListener, i.prototype.once = function (e, t) {\n              function r() {\n                this.removeListener(e, r), i || (i = !0, t.apply(this, arguments));\n              }\n\n              if (!a(t)) throw TypeError(\"listener must be a function\");\n              var i = !1;\n              return r.listener = t, this.on(e, r), this;\n            }, i.prototype.removeListener = function (e, t) {\n              var r, i, n, o;\n              if (!a(t)) throw TypeError(\"listener must be a function\");\n              if (!this._events || !this._events[e]) return this;\n              if (r = this._events[e], n = r.length, i = -1, r === t || a(r.listener) && r.listener === t) delete this._events[e], this._events.removeListener && this.emit(\"removeListener\", e, t);else if (s(r)) {\n                for (o = n; o-- > 0;) {\n                  if (r[o] === t || r[o].listener && r[o].listener === t) {\n                    i = o;\n                    break;\n                  }\n                }\n\n                if (0 > i) return this;\n                1 === r.length ? (r.length = 0, delete this._events[e]) : r.splice(i, 1), this._events.removeListener && this.emit(\"removeListener\", e, t);\n              }\n              return this;\n            }, i.prototype.removeAllListeners = function (e) {\n              var t, r;\n              if (!this._events) return this;\n              if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[e] && delete this._events[e], this;\n\n              if (0 === arguments.length) {\n                for (t in this._events) {\n                  \"removeListener\" !== t && this.removeAllListeners(t);\n                }\n\n                return this.removeAllListeners(\"removeListener\"), this._events = {}, this;\n              }\n\n              if (r = this._events[e], a(r)) this.removeListener(e, r);else if (r) for (; r.length;) {\n                this.removeListener(e, r[r.length - 1]);\n              }\n              return delete this._events[e], this;\n            }, i.prototype.listeners = function (e) {\n              var t;\n              return t = this._events && this._events[e] ? a(this._events[e]) ? [this._events[e]] : this._events[e].slice() : [];\n            }, i.prototype.listenerCount = function (e) {\n              if (this._events) {\n                var t = this._events[e];\n                if (a(t)) return 1;\n                if (t) return t.length;\n              }\n\n              return 0;\n            }, i.listenerCount = function (e, t) {\n              return e.listenerCount(t);\n            };\n          }, {}],\n          2: [function (t, r, i) {\n            !function (t) {\n              var a = {\n                buildAbsoluteURL: function buildAbsoluteURL(e, t) {\n                  if (t = t.trim(), /^[a-z]+:/i.test(t)) return t;\n                  var r = null,\n                      i = null,\n                      n = /^([^#]*)(.*)$/.exec(t);\n                  n && (i = n[2], t = n[1]);\n                  var s = /^([^\\?]*)(.*)$/.exec(t);\n                  s && (r = s[2], t = s[1]);\n                  var o = /^([^#]*)(.*)$/.exec(e);\n                  o && (e = o[1]);\n                  var l = /^([^\\?]*)(.*)$/.exec(e);\n                  l && (e = l[1]);\n                  var u = /^(([a-z]+:)?\\/\\/[a-z0-9\\.\\-_~]+(:[0-9]+)?)?(\\/.*)$/i.exec(e);\n                  if (!u) throw Error(\"Error trying to parse base URL.\");\n                  var d = u[2] || \"\",\n                      f = u[1] || \"\",\n                      h = u[4],\n                      c = null;\n                  return c = /^\\/\\//.test(t) ? d + \"//\" + a.buildAbsolutePath(\"\", t.substring(2)) : /^\\//.test(t) ? f + \"/\" + a.buildAbsolutePath(\"\", t.substring(1)) : a.buildAbsolutePath(f + h, t), r && (c += r), i && (c += i), c;\n                },\n                buildAbsolutePath: function buildAbsolutePath(e, t) {\n                  for (var r, i, a = t, n = \"\", s = e.replace(/[^\\/]*$/, a.replace(/(\\/|^)(?:\\.?\\/+)+/g, \"$1\")), o = 0; i = s.indexOf(\"/../\", o), i > -1; o = i + r) {\n                    r = /^\\/(?:\\.\\.\\/)*/.exec(s.slice(i))[0].length, n = (n + s.substring(o, i)).replace(RegExp(\"(?:\\\\/+[^\\\\/]*){0,\" + (r - 1) / 3 + \"}$\"), \"/\");\n                  }\n\n                  return n + s.substr(o);\n                }\n              };\n              \"object\" == typeof i && \"object\" == typeof r ? r.exports = a : \"function\" == typeof e && e.amd ? e([], function () {\n                return a;\n              }) : \"object\" == typeof i ? i.URLToolkit = a : t.URLToolkit = a;\n            }(this);\n          }, {}],\n          3: [function (e, t, r) {\n            var i = arguments[3],\n                a = arguments[4],\n                n = arguments[5],\n                s = JSON.stringify;\n\n            t.exports = function (e, t) {\n              function r(e) {\n                p[e] = !0;\n\n                for (var t in a[e][1]) {\n                  var i = a[e][1][t];\n                  p[i] || r(i);\n                }\n              }\n\n              for (var o, l = Object.keys(n), u = 0, d = l.length; d > u; u++) {\n                var f = l[u],\n                    h = n[f].exports;\n\n                if (h === e || h && h.default === e) {\n                  o = f;\n                  break;\n                }\n              }\n\n              if (!o) {\n                o = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n                for (var c = {}, u = 0, d = l.length; d > u; u++) {\n                  var f = l[u];\n                  c[f] = f;\n                }\n\n                a[o] = [Function([\"require\", \"module\", \"exports\"], \"(\" + e + \")(self)\"), c];\n              }\n\n              var v = Math.floor(Math.pow(16, 8) * Math.random()).toString(16),\n                  g = {};\n              g[o] = o, a[v] = [Function([\"require\"], \"var f = require(\" + s(o) + \");(f.default ? f.default : f)(self);\"), g];\n              var p = {};\n              r(v);\n              var y = \"(\" + i + \")({\" + Object.keys(p).map(function (e) {\n                return s(e) + \":[\" + a[e][0] + \",\" + s(a[e][1]) + \"]\";\n              }).join(\",\") + \"},{},[\" + s(v) + \"])\",\n                  m = window.URL || window.webkitURL || window.mozURL || window.msURL,\n                  E = new Blob([y], {\n                type: \"text/javascript\"\n              });\n              if (t && t.bare) return E;\n              var b = m.createObjectURL(E),\n                  R = new Worker(b);\n              return R.objectURL = b, R;\n            };\n          }, {}],\n          4: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(30),\n                c = i(h),\n                v = e(26),\n                g = e(45),\n                p = e(9),\n                y = i(p),\n                m = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.FRAG_LOADING, u.default.FRAG_LOADED, u.default.FRAG_BUFFERED, u.default.ERROR));\n                return r.lastLoadedFragLevel = 0, r._autoLevelCapping = -1, r._nextAutoLevel = -1, r.hls = e, r.onCheck = r.abandonRulesCheck.bind(r), r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.clearTimer(), f.default.prototype.destroy.call(this);\n                }\n              }, {\n                key: \"onFragLoading\",\n                value: function value(e) {\n                  var t = e.frag;\n\n                  if (\"main\" === t.type) {\n                    if (this.timer || (this.timer = setInterval(this.onCheck, 100)), !this.bwEstimator) {\n                      var r = this.hls,\n                          i = e.frag.level,\n                          a = r.levels[i].details.live,\n                          n = r.config,\n                          s = void 0,\n                          o = void 0;\n                      a ? (s = n.abrEwmaFastLive, o = n.abrEwmaSlowLive) : (s = n.abrEwmaFastVoD, o = n.abrEwmaSlowVoD), this.bwEstimator = new y.default(r, o, s, n.abrEwmaDefaultEstimate);\n                    }\n\n                    this.fragCurrent = t;\n                  }\n                }\n              }, {\n                key: \"abandonRulesCheck\",\n                value: function value() {\n                  var e = this.hls,\n                      t = e.media,\n                      r = this.fragCurrent,\n                      i = r.loader,\n                      a = this.minAutoLevel;\n                  if (!i || i.stats && i.stats.aborted) return g.logger.warn(\"frag loader destroy or aborted, disarm abandonRules\"), void this.clearTimer();\n                  var n = i.stats;\n\n                  if (t && (!t.paused && 0 !== t.playbackRate || !t.readyState) && r.autoLevel && r.level) {\n                    var s = performance.now() - n.trequest,\n                        o = Math.abs(t.playbackRate);\n\n                    if (s > 500 * r.duration / o) {\n                      var l = e.levels,\n                          d = Math.max(1, n.bw ? n.bw / 8 : 1e3 * n.loaded / s),\n                          f = n.total ? n.total : Math.max(n.loaded, Math.round(r.duration * l[r.level].bitrate / 8)),\n                          h = t.currentTime,\n                          v = (f - n.loaded) / d,\n                          p = (c.default.bufferInfo(t, h, e.config.maxBufferHole).end - h) / o;\n\n                      if (2 * r.duration / o > p && v > p) {\n                        var y = void 0,\n                            m = void 0;\n\n                        for (m = r.level - 1; m > a && (y = r.duration * l[m].bitrate / (6.4 * d), p <= y); m--) {\n                          ;\n                        }\n\n                        v > y && (g.logger.warn(\"loading too slow, abort fragment loading and switch to level \" + m + \":fragLoadedDelay[\" + m + \"]<fragLoadedDelay[\" + (r.level - 1) + \"];bufferStarvationDelay:\" + y.toFixed(1) + \"<\" + v.toFixed(1) + \":\" + p.toFixed(1)), e.nextLoadLevel = m, this.bwEstimator.sample(s, n.loaded), i.abort(), this.clearTimer(), e.trigger(u.default.FRAG_LOAD_EMERGENCY_ABORTED, {\n                          frag: r,\n                          stats: n\n                        }));\n                      }\n                    }\n                  }\n                }\n              }, {\n                key: \"onFragLoaded\",\n                value: function value(e) {\n                  var t = e.frag;\n\n                  if (\"main\" === t.type && (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, e.frag.bitrateTest)) {\n                    var r = e.stats;\n                    r.tparsed = r.tbuffered = r.tload, this.onFragBuffered(e);\n                  }\n                }\n              }, {\n                key: \"onFragBuffered\",\n                value: function value(e) {\n                  var t = e.stats,\n                      r = e.frag;\n\n                  if (t.aborted !== !0 && 1 === r.loadCounter && \"main\" === r.type && (!r.bitrateTest || t.tload === t.tbuffered)) {\n                    var i = t.tparsed - t.trequest;\n                    g.logger.log(\"latency/loading/parsing/append/kbps:\" + Math.round(t.tfirst - t.trequest) + \"/\" + Math.round(t.tload - t.tfirst) + \"/\" + Math.round(t.tparsed - t.tload) + \"/\" + Math.round(t.tbuffered - t.tparsed) + \"/\" + Math.round(8 * t.loaded / (t.tbuffered - t.trequest))), this.bwEstimator.sample(i, t.loaded), this.bitrateTestDelay = r.bitrateTest ? i / 1e3 : 0;\n                  }\n                }\n              }, {\n                key: \"onError\",\n                value: function value(e) {\n                  switch (e.details) {\n                    case v.ErrorDetails.FRAG_LOAD_ERROR:\n                    case v.ErrorDetails.FRAG_LOAD_TIMEOUT:\n                      this.clearTimer();\n                  }\n                }\n              }, {\n                key: \"clearTimer\",\n                value: function value() {\n                  this.timer && (clearInterval(this.timer), this.timer = null);\n                }\n              }, {\n                key: \"findBestLevel\",\n                value: function value(e, t, r, i, a, n, s, o, l) {\n                  for (var u = a; u >= i; u--) {\n                    var d = l[u],\n                        f = d.details,\n                        h = f ? f.totalduration / f.fragments.length : t,\n                        c = !!f && f.live,\n                        v = void 0;\n                    v = u > e ? o * r : s * r;\n                    var p = l[u].bitrate,\n                        y = p * h / v;\n                    if (g.logger.trace(\"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: \" + u + \"/\" + Math.round(v) + \"/\" + p + \"/\" + h + \"/\" + n + \"/\" + y), v > p && (!y || c || n > y)) return u;\n                  }\n\n                  return -1;\n                }\n              }, {\n                key: \"autoLevelCapping\",\n                get: function get() {\n                  return this._autoLevelCapping;\n                },\n                set: function set(e) {\n                  this._autoLevelCapping = e;\n                }\n              }, {\n                key: \"nextAutoLevel\",\n                get: function get() {\n                  var e = this._nextAutoLevel,\n                      t = this.bwEstimator,\n                      r = this.hls,\n                      i = r.levels,\n                      a = r.config.minAutoBitrate;\n                  if (!(e === -1 || t && t.canEstimate())) return Math.min(e, this.maxAutoLevel);\n                  var n = this.nextABRAutoLevel;\n                  if (e !== -1 && (n = Math.min(e, n)), void 0 !== a) for (; a > i[n].bitrate;) {\n                    n++;\n                  }\n                  return n;\n                },\n                set: function set(e) {\n                  this._nextAutoLevel = e;\n                }\n              }, {\n                key: \"minAutoLevel\",\n                get: function get() {\n                  for (var e = this.hls, t = e.levels, r = e.config.minAutoBitrate, i = t ? t.length : 0, a = 0; i > a; a++) {\n                    if (t[a].bitrate > r) return a;\n                  }\n\n                  return 0;\n                }\n              }, {\n                key: \"maxAutoLevel\",\n                get: function get() {\n                  var e,\n                      t = this.hls.levels,\n                      r = this._autoLevelCapping;\n                  return e = r === -1 && t && t.length ? t.length - 1 : r;\n                }\n              }, {\n                key: \"nextABRAutoLevel\",\n                get: function get() {\n                  var e = this.hls,\n                      t = this.maxAutoLevel,\n                      r = e.levels,\n                      i = e.config,\n                      a = this.minAutoLevel,\n                      n = e.media,\n                      s = this.lastLoadedFragLevel,\n                      o = this.fragCurrent ? this.fragCurrent.duration : 0,\n                      l = n ? n.currentTime : 0,\n                      u = n && 0 !== n.playbackRate ? Math.abs(n.playbackRate) : 1,\n                      d = this.bwEstimator ? this.bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate,\n                      f = (c.default.bufferInfo(n, l, i.maxBufferHole).end - l) / u,\n                      h = this.findBestLevel(s, o, d, a, t, f, i.abrBandWidthFactor, i.abrBandWidthUpFactor, r);\n\n                  if (0 > h) {\n                    g.logger.trace(\"rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering\");\n                    var v = i.maxStarvationDelay,\n                        p = i.abrBandWidthFactor,\n                        y = i.abrBandWidthUpFactor;\n\n                    if (0 === f) {\n                      var m = this.bitrateTestDelay;\n                      m && (v = i.maxLoadingDelay - m, g.logger.trace(\"bitrate test took \" + Math.round(1e3 * m) + \"ms, set first fragment max fetchDuration to \" + Math.round(1e3 * v) + \" ms\"), p = y = 1);\n                    }\n\n                    return h = this.findBestLevel(s, o, d, a, t, f + v, p, y, r), Math.max(h, 0);\n                  }\n\n                  return h;\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = m;\n          }, {\n            26: 26,\n            27: 27,\n            28: 28,\n            30: 30,\n            45: 45,\n            9: 9\n          }],\n          5: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(41),\n                u = i(l),\n                d = e(30),\n                f = i(d),\n                h = e(22),\n                c = i(h),\n                v = e(28),\n                g = i(v),\n                p = e(27),\n                y = i(p),\n                m = e(31),\n                E = i(m),\n                b = e(46),\n                R = i(b),\n                _ = e(26),\n                k = e(45),\n                T = {\n              STOPPED: \"STOPPED\",\n              STARTING: \"STARTING\",\n              IDLE: \"IDLE\",\n              PAUSED: \"PAUSED\",\n              KEY_LOADING: \"KEY_LOADING\",\n              FRAG_LOADING: \"FRAG_LOADING\",\n              FRAG_LOADING_WAITING_RETRY: \"FRAG_LOADING_WAITING_RETRY\",\n              WAITING_TRACK: \"WAITING_TRACK\",\n              PARSING: \"PARSING\",\n              PARSED: \"PARSED\",\n              ENDED: \"ENDED\",\n              ERROR: \"ERROR\"\n            },\n                A = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, g.default.MEDIA_ATTACHED, g.default.MEDIA_DETACHING, g.default.AUDIO_TRACKS_UPDATED, g.default.AUDIO_TRACK_SWITCH, g.default.AUDIO_TRACK_LOADED, g.default.KEY_LOADED, g.default.FRAG_LOADED, g.default.FRAG_PARSING_INIT_SEGMENT, g.default.FRAG_PARSING_DATA, g.default.FRAG_PARSED, g.default.ERROR, g.default.BUFFER_CREATED, g.default.BUFFER_APPENDED, g.default.BUFFER_FLUSHED));\n                return r.config = e.config, r.audioCodecSwap = !1, r.ticks = 0, r.ontick = r.tick.bind(r), r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), y.default.prototype.destroy.call(this), this.state = T.STOPPED;\n                }\n              }, {\n                key: \"startLoad\",\n                value: function value(e) {\n                  if (this.tracks) {\n                    var t = this.lastCurrentTime;\n                    this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.fragLoadError = 0, t > 0 && e === -1 ? (k.logger.log(\"audio:override startPosition with lastCurrentTime @\" + t.toFixed(3)), this.state = T.IDLE) : (this.lastCurrentTime = this.startPosition ? this.startPosition : e, this.state = T.STARTING), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick();\n                  } else this.startPosition = e, this.state = T.STOPPED;\n                }\n              }, {\n                key: \"stopLoad\",\n                value: function value() {\n                  var e = this.fragCurrent;\n                  e && (e.loader && e.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = T.STOPPED;\n                }\n              }, {\n                key: \"tick\",\n                value: function value() {\n                  this.ticks++, 1 === this.ticks && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);\n                }\n              }, {\n                key: \"doTick\",\n                value: function value() {\n                  var e,\n                      t,\n                      r,\n                      i = this.hls,\n                      a = i.config;\n\n                  switch (this.state) {\n                    case T.ERROR:\n                    case T.PAUSED:\n                      break;\n\n                    case T.STARTING:\n                      this.state = T.WAITING_TRACK, this.loadedmetadata = !1;\n                      break;\n\n                    case T.IDLE:\n                      if (!this.media && (this.startFragRequested || !a.startFragPrefetch)) break;\n                      e = this.loadedmetadata ? this.media.currentTime : this.nextLoadPosition;\n                      var n = this.mediaBuffer ? this.mediaBuffer : this.media,\n                          s = f.default.bufferInfo(n, e, a.maxBufferHole),\n                          o = s.len,\n                          l = s.end,\n                          d = this.fragPrevious,\n                          h = a.maxMaxBufferLength;\n\n                      if (h > o && this.tracks.length > this.trackId) {\n                        if (r = this.tracks[this.trackId].details, void 0 === r) {\n                          this.state = T.WAITING_TRACK;\n                          break;\n                        }\n\n                        if (!r.live && d && d.sn === r.endSN && (!this.media.seeking || d.duration / 2 > this.media.duration - l)) {\n                          this.hls.trigger(g.default.BUFFER_EOS, {\n                            type: \"audio\"\n                          }), this.state = T.ENDED;\n                          break;\n                        }\n\n                        var c = r.fragments,\n                            v = c.length,\n                            p = c[0].start,\n                            y = c[v - 1].start + c[v - 1].duration,\n                            m = void 0;\n                        if (p > l ? m = c[0] : !function () {\n                          var e = void 0,\n                              t = a.maxFragLookUpTolerance;\n                          y > l ? (l > y - t && (t = 0), e = u.default.search(c, function (e) {\n                            return e.start + e.duration - t > l ? e.start - t > l ? -1 : 0 : 1;\n                          })) : e = c[v - 1], e && (m = e, p = e.start, d && m.level === d.level && m.sn === d.sn && (r.endSN > m.sn ? (m = c[m.sn + 1 - r.startSN], k.logger.log(\"SN just loaded, load next one: \" + m.sn)) : m = null));\n                        }(), m) if (null != m.decryptdata.uri && null == m.decryptdata.key) k.logger.log(\"Loading key for \" + m.sn + \" of [\" + r.startSN + \" ,\" + r.endSN + \"],track \" + this.trackId), this.state = T.KEY_LOADING, i.trigger(g.default.KEY_LOADING, {\n                          frag: m\n                        });else {\n                          if (k.logger.log(\"Loading \" + m.sn + \" of [\" + r.startSN + \" ,\" + r.endSN + \"],track \" + this.trackId + \", currentTime:\" + e + \",bufferEnd:\" + l.toFixed(3)), void 0 !== this.fragLoadIdx ? this.fragLoadIdx++ : this.fragLoadIdx = 0, m.loadCounter) {\n                            m.loadCounter++;\n                            var E = a.fragLoadingLoopThreshold;\n                            if (m.loadCounter > E && Math.abs(this.fragLoadIdx - m.loadIdx) < E) return void i.trigger(g.default.ERROR, {\n                              type: _.ErrorTypes.MEDIA_ERROR,\n                              details: _.ErrorDetails.FRAG_LOOP_LOADING_ERROR,\n                              fatal: !1,\n                              frag: m\n                            });\n                          } else m.loadCounter = 1;\n\n                          m.loadIdx = this.fragLoadIdx, this.fragCurrent = m, this.startFragRequested = !0, this.nextLoadPosition = m.start + m.duration, i.trigger(g.default.FRAG_LOADING, {\n                            frag: m\n                          }), this.state = T.FRAG_LOADING;\n                        }\n                      }\n\n                      break;\n\n                    case T.WAITING_TRACK:\n                      t = this.tracks[this.trackId], t && t.details && (this.state = T.IDLE);\n                      break;\n\n                    case T.FRAG_LOADING_WAITING_RETRY:\n                      var b = performance.now(),\n                          R = this.retryDate;\n                      n = this.media;\n                      var A = n && n.seeking;\n                      R && R > b && !A || (k.logger.log(\"audioStreamController: retryDate reached, switch back to IDLE state\"), this.state = T.IDLE);\n                      break;\n\n                    case T.STOPPED:\n                    case T.FRAG_LOADING:\n                    case T.PARSING:\n                    case T.PARSED:\n                    case T.ENDED:\n                  }\n                }\n              }, {\n                key: \"onMediaAttached\",\n                value: function value(e) {\n                  var t = this.media = this.mediaBuffer = e.media;\n                  this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener(\"seeking\", this.onvseeking), t.addEventListener(\"ended\", this.onvended);\n                  var r = this.config;\n                  this.tracks && r.autoStartLoad && this.startLoad(r.startPosition);\n                }\n              }, {\n                key: \"onMediaDetaching\",\n                value: function value() {\n                  var e = this.media;\n                  e && e.ended && (k.logger.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0);\n                  var t = this.tracks;\n                  t && t.forEach(function (e) {\n                    e.details && e.details.fragments.forEach(function (e) {\n                      e.loadCounter = void 0;\n                    });\n                  }), e && (e.removeEventListener(\"seeking\", this.onvseeking), e.removeEventListener(\"ended\", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad();\n                }\n              }, {\n                key: \"onMediaSeeking\",\n                value: function value() {\n                  this.state === T.ENDED && (this.state = T.IDLE), this.media && (this.lastCurrentTime = this.media.currentTime), void 0 !== this.fragLoadIdx && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.tick();\n                }\n              }, {\n                key: \"onMediaEnded\",\n                value: function value() {\n                  this.startPosition = this.lastCurrentTime = 0;\n                }\n              }, {\n                key: \"onAudioTracksUpdated\",\n                value: function value(e) {\n                  k.logger.log(\"audio tracks updated\"), this.tracks = e.audioTracks;\n                }\n              }, {\n                key: \"onAudioTrackSwitch\",\n                value: function value(e) {\n                  var t = !!e.url;\n                  this.trackId = e.id, this.state = T.IDLE, this.fragCurrent = null, this.state = T.PAUSED, t ? this.timer || (this.timer = setInterval(this.ontick, 100)) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.hls.trigger(g.default.BUFFER_FLUSHING, {\n                    startOffset: 0,\n                    endOffset: Number.POSITIVE_INFINITY,\n                    type: \"audio\"\n                  }), this.tick();\n                }\n              }, {\n                key: \"onAudioTrackLoaded\",\n                value: function value(e) {\n                  var t = e.details,\n                      r = e.id,\n                      i = this.tracks[r],\n                      a = t.totalduration;\n\n                  if (k.logger.log(\"track \" + r + \" loaded [\" + t.startSN + \",\" + t.endSN + \"],duration:\" + a), t.PTSKnown = !1, i.details = t, !this.startFragRequested) {\n                    if (this.startPosition === -1) {\n                      var n = t.startTimeOffset;\n                      isNaN(n) ? this.startPosition = 0 : (k.logger.log(\"start time offset found in playlist, adjust startPosition to \" + n), this.startPosition = n);\n                    }\n\n                    this.nextLoadPosition = this.startPosition;\n                  }\n\n                  this.state === T.WAITING_TRACK && (this.state = T.IDLE), this.tick();\n                }\n              }, {\n                key: \"onKeyLoaded\",\n                value: function value() {\n                  this.state === T.KEY_LOADING && (this.state = T.IDLE, this.tick());\n                }\n              }, {\n                key: \"onFragLoaded\",\n                value: function value(e) {\n                  var t = this.fragCurrent;\n\n                  if (this.state === T.FRAG_LOADING && t && \"audio\" === e.frag.type && e.frag.level === t.level && e.frag.sn === t.sn) {\n                    this.state = T.PARSING, this.stats = e.stats;\n                    var r = this.tracks[this.trackId],\n                        i = r.details,\n                        a = i.totalduration,\n                        n = t.start,\n                        s = t.level,\n                        o = t.sn,\n                        l = this.config.defaultAudioCodec || r.audioCodec;\n                    this.pendingAppending = 0, this.demuxer || (this.demuxer = new c.default(this.hls, \"audio\")), k.logger.log(\"Demuxing \" + o + \" of [\" + i.startSN + \" ,\" + i.endSN + \"],track \" + s);\n                    var u = i.PTSKnown || !i.live;\n                    this.demuxer.push(e.payload, l, null, n, t.cc, s, o, a, t.decryptdata, u);\n                  }\n\n                  this.fragLoadError = 0;\n                }\n              }, {\n                key: \"onFragParsingInitSegment\",\n                value: function value(e) {\n                  var t = this.fragCurrent;\n\n                  if (t && \"audio\" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING) {\n                    var r = e.tracks,\n                        i = void 0;\n\n                    if (i = r.audio) {\n                      i.levelCodec = \"mp4a.40.2\", i.id = e.id, this.hls.trigger(g.default.BUFFER_CODECS, r), k.logger.log(\"audio track:audio,container:\" + i.container + \",codecs[level/parsed]=[\" + i.levelCodec + \"/\" + i.codec + \"]\");\n                      var a = i.initSegment;\n                      a && (this.pendingAppending++, this.hls.trigger(g.default.BUFFER_APPENDING, {\n                        type: \"audio\",\n                        data: a,\n                        parent: \"audio\",\n                        content: \"initSegment\"\n                      })), this.tick();\n                    }\n                  }\n                }\n              }, {\n                key: \"onFragParsingData\",\n                value: function value(e) {\n                  var t = this,\n                      r = this.fragCurrent;\n\n                  if (r && \"audio\" === e.id && e.sn === r.sn && e.level === r.level && this.state === T.PARSING) {\n                    var i = this.tracks[this.trackId],\n                        a = this.fragCurrent;\n                    k.logger.log(\"parsed \" + e.type + \",PTS:[\" + e.startPTS.toFixed(3) + \",\" + e.endPTS.toFixed(3) + \"],DTS:[\" + e.startDTS.toFixed(3) + \"/\" + e.endDTS.toFixed(3) + \"],nb:\" + e.nb), E.default.updateFragPTSDTS(i.details, a.sn, e.startPTS, e.endPTS), [e.data1, e.data2].forEach(function (r) {\n                      r && (t.pendingAppending++, t.hls.trigger(g.default.BUFFER_APPENDING, {\n                        type: e.type,\n                        data: r,\n                        parent: \"audio\",\n                        content: \"data\"\n                      }));\n                    }), this.tick();\n                  }\n                }\n              }, {\n                key: \"onFragParsed\",\n                value: function value(e) {\n                  var t = this.fragCurrent;\n                  t && \"audio\" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING && (this.stats.tparsed = performance.now(), this.state = T.PARSED, this._checkAppendedParsed());\n                }\n              }, {\n                key: \"onBufferCreated\",\n                value: function value(e) {\n                  var t = e.tracks.audio;\n                  t && (this.mediaBuffer = t.buffer, this.loadedmetadata = !0);\n                }\n              }, {\n                key: \"onBufferAppended\",\n                value: function value(e) {\n                  if (\"audio\" === e.parent) switch (this.state) {\n                    case T.PARSING:\n                    case T.PARSED:\n                      this.pendingAppending--, this._checkAppendedParsed();\n                  }\n                }\n              }, {\n                key: \"_checkAppendedParsed\",\n                value: function value() {\n                  if (this.state === T.PARSED && 0 === this.pendingAppending) {\n                    var e = this.fragCurrent,\n                        t = this.stats;\n\n                    if (e) {\n                      this.fragPrevious = e, t.tbuffered = performance.now(), this.hls.trigger(g.default.FRAG_BUFFERED, {\n                        stats: t,\n                        frag: e,\n                        id: \"audio\"\n                      });\n                      var r = this.mediaBuffer ? this.mediaBuffer : this.media;\n                      k.logger.log(\"audio buffered : \" + R.default.toString(r.buffered)), this.state = T.IDLE;\n                    }\n\n                    this.tick();\n                  }\n                }\n              }, {\n                key: \"onError\",\n                value: function value(e) {\n                  var t = e.frag;\n                  if (!t || \"audio\" === t.type) switch (e.details) {\n                    case _.ErrorDetails.FRAG_LOAD_ERROR:\n                    case _.ErrorDetails.FRAG_LOAD_TIMEOUT:\n                      if (!e.fatal) {\n                        var r = this.fragLoadError;\n                        r ? r++ : r = 1;\n                        var i = this.config;\n                        if (i.fragLoadingMaxRetry < r) k.logger.error(\"audioStreamController: \" + e.details + \" reaches max retry, redispatch as fatal ...\"), e.fatal = !0, this.hls.trigger(g.default.ERROR, e), this.state = T.ERROR;else {\n                          this.fragLoadError = r, t.loadCounter = 0;\n                          var a = Math.min(Math.pow(2, r - 1) * i.fragLoadingRetryDelay, i.fragLoadingMaxRetryTimeout);\n                          k.logger.warn(\"audioStreamController: frag loading failed, retry in \" + a + \" ms\"), this.retryDate = performance.now() + a, this.state = T.FRAG_LOADING_WAITING_RETRY;\n                        }\n                      }\n\n                      break;\n\n                    case _.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n                    case _.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n                    case _.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n                    case _.ErrorDetails.KEY_LOAD_ERROR:\n                    case _.ErrorDetails.KEY_LOAD_TIMEOUT:\n                      this.state !== T.ERROR && (this.state = e.fatal ? T.ERROR : T.IDLE, k.logger.warn(\"audioStreamController: \" + e.details + \" while loading frag,switch to \" + this.state + \" state ...\"));\n                  }\n                }\n              }, {\n                key: \"onBufferFlushed\",\n                value: function value() {\n                  this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, this.state = T.IDLE, this.fragPrevious = null, this.tick();\n                }\n              }]), t;\n            }(y.default);\n\n            r.default = A;\n          }, {\n            22: 22,\n            26: 26,\n            27: 27,\n            28: 28,\n            30: 30,\n            31: 31,\n            41: 41,\n            45: 45,\n            46: 46\n          }],\n          6: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(45),\n                c = function (e) {\n              function t(e) {\n                return a(this, t), n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.MANIFEST_LOADING, u.default.MANIFEST_LOADED, u.default.AUDIO_TRACK_LOADED));\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  f.default.prototype.destroy.call(this);\n                }\n              }, {\n                key: \"onManifestLoading\",\n                value: function value() {\n                  this.tracks = [], this.trackId = -1;\n                }\n              }, {\n                key: \"onManifestLoaded\",\n                value: function value(e) {\n                  var t = this,\n                      r = e.audioTracks || [],\n                      i = !1;\n                  this.tracks = r, this.hls.trigger(u.default.AUDIO_TRACKS_UPDATED, {\n                    audioTracks: r\n                  });\n                  var a = 0;\n                  r.forEach(function (e) {\n                    return e.default ? (t.audioTrack = a, void (i = !0)) : void a++;\n                  }), i === !1 && r.length && (h.logger.log(\"no default audio track defined, use first audio track as default\"), this.audioTrack = 0);\n                }\n              }, {\n                key: \"onAudioTrackLoaded\",\n                value: function value(e) {\n                  this.tracks.length > e.id && (h.logger.log(\"audioTrack \" + e.id + \" loaded\"), this.tracks[e.id].details = e.details, e.details.live && !this.timer && (this.timer = setInterval(this.ontick, 1e3 * e.details.targetduration)), !e.details.live && this.timer && (clearInterval(this.timer), this.timer = null));\n                }\n              }, {\n                key: \"setAudioTrackInternal\",\n                value: function value(e) {\n                  if (e >= 0 && this.tracks.length > e) {\n                    this.timer && (clearInterval(this.timer), this.timer = null), this.trackId = e, h.logger.log(\"switching to audioTrack \" + e);\n                    var t = this.tracks[e],\n                        r = t.type,\n                        i = t.url;\n                    this.hls.trigger(u.default.AUDIO_TRACK_SWITCH, {\n                      id: e,\n                      type: r,\n                      url: i\n                    });\n                    var a = t.details;\n                    !i || void 0 !== a && a.live !== !0 || (h.logger.log(\"(re)loading playlist for audioTrack \" + e), this.hls.trigger(u.default.AUDIO_TRACK_LOADING, {\n                      url: i,\n                      id: e\n                    }));\n                  }\n                }\n              }, {\n                key: \"audioTracks\",\n                get: function get() {\n                  return this.tracks;\n                }\n              }, {\n                key: \"audioTrack\",\n                get: function get() {\n                  return this.trackId;\n                },\n                set: function set(e) {\n                  this.trackId === e && void 0 !== this.tracks[e].details || this.setAudioTrackInternal(e);\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = c;\n          }, {\n            27: 27,\n            28: 28,\n            45: 45\n          }],\n          7: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(45),\n                c = e(26),\n                v = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.MEDIA_ATTACHING, u.default.MEDIA_DETACHING, u.default.MANIFEST_PARSED, u.default.BUFFER_RESET, u.default.BUFFER_APPENDING, u.default.BUFFER_CODECS, u.default.BUFFER_EOS, u.default.BUFFER_FLUSHING, u.default.LEVEL_PTS_UPDATED, u.default.LEVEL_UPDATED));\n                return r._msDuration = null, r._levelDuration = null, r.onsbue = r.onSBUpdateEnd.bind(r), r.onsbe = r.onSBUpdateError.bind(r), r.pendingTracks = {}, r.tracks = {}, r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  f.default.prototype.destroy.call(this);\n                }\n              }, {\n                key: \"onLevelPtsUpdated\",\n                value: function value(e) {\n                  var t = e.type,\n                      r = this.tracks.audio;\n\n                  if (\"audio\" === t && r && \"audio/mpeg\" === r.container) {\n                    var i = this.sourceBuffer.audio,\n                        a = Math.abs(i.timestampOffset - e.start);\n\n                    if (a > .1) {\n                      var n = i.updating;\n\n                      try {\n                        i.abort();\n                      } catch (e) {\n                        n = !0, h.logger.warn(\"can not abort audio buffer: \" + e);\n                      }\n\n                      n ? this.audioTimestampOffset = e.start : (h.logger.warn(\"change mpeg audio timestamp offset from \" + i.timestampOffset + \" to \" + e.start), i.timestampOffset = e.start);\n                    }\n                  }\n                }\n              }, {\n                key: \"onManifestParsed\",\n                value: function value(e) {\n                  var t = e.audio,\n                      r = e.video,\n                      i = 0;\n                  e.altAudio && (t || r) && (i = (t ? 1 : 0) + (r ? 1 : 0), h.logger.log(i + \" sourceBuffer(s) expected\")), this.sourceBufferNb = i;\n                }\n              }, {\n                key: \"onMediaAttaching\",\n                value: function value(e) {\n                  var t = this.media = e.media;\n\n                  if (t) {\n                    var r = this.mediaSource = new MediaSource();\n                    this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this), r.addEventListener(\"sourceopen\", this.onmso), r.addEventListener(\"sourceended\", this.onmse), r.addEventListener(\"sourceclose\", this.onmsc), t.src = URL.createObjectURL(r);\n                  }\n                }\n              }, {\n                key: \"onMediaDetaching\",\n                value: function value() {\n                  h.logger.log(\"media source detaching\");\n                  var e = this.mediaSource;\n\n                  if (e) {\n                    if (\"open\" === e.readyState) try {\n                      e.endOfStream();\n                    } catch (e) {\n                      h.logger.warn(\"onMediaDetaching:\" + e.message + \" while calling endOfStream\");\n                    }\n                    e.removeEventListener(\"sourceopen\", this.onmso), e.removeEventListener(\"sourceended\", this.onmse), e.removeEventListener(\"sourceclose\", this.onmsc), this.media && (URL.revokeObjectURL(this.media.src), this.media.removeAttribute(\"src\"), this.media.load()), this.mediaSource = null, this.media = null, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;\n                  }\n\n                  this.onmso = this.onmse = this.onmsc = null, this.hls.trigger(u.default.MEDIA_DETACHED);\n                }\n              }, {\n                key: \"onMediaSourceOpen\",\n                value: function value() {\n                  h.logger.log(\"media source opened\"), this.hls.trigger(u.default.MEDIA_ATTACHED, {\n                    media: this.media\n                  });\n                  var e = this.mediaSource;\n                  e && e.removeEventListener(\"sourceopen\", this.onmso), this.checkPendingTracks();\n                }\n              }, {\n                key: \"checkPendingTracks\",\n                value: function value() {\n                  var e = this.pendingTracks,\n                      t = Object.keys(e).length;\n                  !t || this.sourceBufferNb > t && 0 !== this.sourceBufferNb || (this.createSourceBuffers(e), this.pendingTracks = {}, this.doAppending());\n                }\n              }, {\n                key: \"onMediaSourceClose\",\n                value: function value() {\n                  h.logger.log(\"media source closed\");\n                }\n              }, {\n                key: \"onMediaSourceEnded\",\n                value: function value() {\n                  h.logger.log(\"media source ended\");\n                }\n              }, {\n                key: \"onSBUpdateEnd\",\n                value: function value() {\n                  if (this.audioTimestampOffset) {\n                    var e = this.sourceBuffer.audio;\n                    h.logger.warn(\"change mpeg audio timestamp offset from \" + e.timestampOffset + \" to \" + this.audioTimestampOffset), e.timestampOffset = this.audioTimestampOffset, delete this.audioTimestampOffset;\n                  }\n\n                  this._needsFlush && this.doFlush(), this._needsEos && this.checkEos(), this.appending = !1, this.hls.trigger(u.default.BUFFER_APPENDED, {\n                    parent: this.parent\n                  }), this._needsFlush || this.doAppending(), this.updateMediaElementDuration();\n                }\n              }, {\n                key: \"onSBUpdateError\",\n                value: function value(e) {\n                  h.logger.error(\"sourceBuffer error:\" + e), this.hls.trigger(u.default.ERROR, {\n                    type: c.ErrorTypes.MEDIA_ERROR,\n                    details: c.ErrorDetails.BUFFER_APPENDING_ERROR,\n                    fatal: !1\n                  });\n                }\n              }, {\n                key: \"onBufferReset\",\n                value: function value() {\n                  var e = this.sourceBuffer;\n\n                  for (var t in e) {\n                    var r = e[t];\n\n                    try {\n                      this.mediaSource.removeSourceBuffer(r), r.removeEventListener(\"updateend\", this.onsbue), r.removeEventListener(\"error\", this.onsbe);\n                    } catch (e) {}\n                  }\n\n                  this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;\n                }\n              }, {\n                key: \"onBufferCodecs\",\n                value: function value(e) {\n                  if (0 === Object.keys(this.sourceBuffer).length) {\n                    for (var t in e) {\n                      this.pendingTracks[t] = e[t];\n                    }\n\n                    var r = this.mediaSource;\n                    r && \"open\" === r.readyState && this.checkPendingTracks();\n                  }\n                }\n              }, {\n                key: \"createSourceBuffers\",\n                value: function value(e) {\n                  var t = this.sourceBuffer,\n                      r = this.mediaSource;\n\n                  for (var i in e) {\n                    if (!t[i]) {\n                      var a = e[i],\n                          n = a.levelCodec || a.codec,\n                          s = a.container + \";codecs=\" + n;\n                      h.logger.log(\"creating sourceBuffer(\" + s + \")\");\n\n                      try {\n                        var o = t[i] = r.addSourceBuffer(s);\n                        o.addEventListener(\"updateend\", this.onsbue), o.addEventListener(\"error\", this.onsbe), this.tracks[i] = {\n                          codec: n,\n                          container: a.container\n                        }, a.buffer = o;\n                      } catch (e) {\n                        h.logger.error(\"error while trying to add sourceBuffer:\" + e.message), this.hls.trigger(u.default.ERROR, {\n                          type: c.ErrorTypes.MEDIA_ERROR,\n                          details: c.ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n                          fatal: !1,\n                          err: e,\n                          mimeType: s\n                        });\n                      }\n                    }\n                  }\n\n                  this.hls.trigger(u.default.BUFFER_CREATED, {\n                    tracks: e\n                  });\n                }\n              }, {\n                key: \"onBufferAppending\",\n                value: function value(e) {\n                  this._needsFlush || (this.segments ? this.segments.push(e) : this.segments = [e], this.doAppending());\n                }\n              }, {\n                key: \"onBufferAppendFail\",\n                value: function value(e) {\n                  h.logger.error(\"sourceBuffer error:\" + e.event), this.hls.trigger(u.default.ERROR, {\n                    type: c.ErrorTypes.MEDIA_ERROR,\n                    details: c.ErrorDetails.BUFFER_APPENDING_ERROR,\n                    fatal: !1,\n                    frag: this.fragCurrent\n                  });\n                }\n              }, {\n                key: \"onBufferEos\",\n                value: function value(e) {\n                  var t = this.sourceBuffer,\n                      r = e.type;\n\n                  for (var i in t) {\n                    r && i !== r || t[i].ended || (t[i].ended = !0, h.logger.log(i + \" sourceBuffer now EOS\"));\n                  }\n\n                  this.checkEos();\n                }\n              }, {\n                key: \"checkEos\",\n                value: function value() {\n                  var e = this.sourceBuffer,\n                      t = this.mediaSource;\n                  if (!t || \"open\" !== t.readyState) return void (this._needsEos = !1);\n\n                  for (var r in e) {\n                    var i = e[r];\n                    if (!i.ended) return;\n                    if (i.updating) return void (this._needsEos = !0);\n                  }\n\n                  h.logger.log(\"all media data available, signal endOfStream() to MediaSource and stop loading fragment\");\n\n                  try {\n                    t.endOfStream();\n                  } catch (e) {\n                    h.logger.warn(\"exception while calling mediaSource.endOfStream()\");\n                  }\n\n                  this._needsEos = !1;\n                }\n              }, {\n                key: \"onBufferFlushing\",\n                value: function value(e) {\n                  this.flushRange.push({\n                    start: e.startOffset,\n                    end: e.endOffset,\n                    type: e.type\n                  }), this.flushBufferCounter = 0, this.doFlush();\n                }\n              }, {\n                key: \"onLevelUpdated\",\n                value: function value(e) {\n                  var t = e.details;\n                  0 !== t.fragments.length && (this._levelDuration = t.totalduration + t.fragments[0].start, this.updateMediaElementDuration());\n                }\n              }, {\n                key: \"updateMediaElementDuration\",\n                value: function value() {\n                  var e = this.media,\n                      t = this.mediaSource,\n                      r = this.sourceBuffer,\n                      i = this._levelDuration;\n\n                  if (null !== i && e && t && r && 0 !== e.readyState && \"open\" === t.readyState) {\n                    for (var a in r) {\n                      if (r[a].updating) return;\n                    }\n\n                    null === this._msDuration && (this._msDuration = t.duration), i > this._msDuration && i > e.duration && (h.logger.log(\"Updating mediasource duration to \" + i.toFixed(3)), this._msDuration = t.duration = i);\n                  }\n                }\n              }, {\n                key: \"doFlush\",\n                value: function value() {\n                  for (; this.flushRange.length;) {\n                    var e = this.flushRange[0];\n                    if (!this.flushBuffer(e.start, e.end, e.type)) return void (this._needsFlush = !0);\n                    this.flushRange.shift(), this.flushBufferCounter = 0;\n                  }\n\n                  if (0 === this.flushRange.length) {\n                    this._needsFlush = !1;\n                    var t = 0,\n                        r = this.sourceBuffer;\n\n                    try {\n                      for (var i in r) {\n                        t += r[i].buffered.length;\n                      }\n                    } catch (e) {\n                      h.logger.error(\"error while accessing sourceBuffer.buffered\");\n                    }\n\n                    this.appended = t, this.hls.trigger(u.default.BUFFER_FLUSHED);\n                  }\n                }\n              }, {\n                key: \"doAppending\",\n                value: function value() {\n                  var e = this.hls,\n                      t = this.sourceBuffer,\n                      r = this.segments;\n\n                  if (Object.keys(t).length) {\n                    if (this.media.error) return this.segments = [], void h.logger.error(\"trying to append although a media error occured, flush segment and abort\");\n                    if (this.appending) return;\n\n                    if (r && r.length) {\n                      var i = r.shift();\n\n                      try {\n                        var a = i.type;\n                        t[a] ? (t[a].ended = !1, this.parent = i.parent, t[a].appendBuffer(i.data), this.appendError = 0, this.appended++, this.appending = !0) : this.onSBUpdateEnd();\n                      } catch (t) {\n                        h.logger.error(\"error while trying to append buffer:\" + t.message), r.unshift(i);\n                        var n = {\n                          type: c.ErrorTypes.MEDIA_ERROR\n                        };\n                        if (22 === t.code) return this.segments = [], n.details = c.ErrorDetails.BUFFER_FULL_ERROR, void e.trigger(u.default.ERROR, n);\n                        if (this.appendError ? this.appendError++ : this.appendError = 1, n.details = c.ErrorDetails.BUFFER_APPEND_ERROR, n.frag = this.fragCurrent, this.appendError > e.config.appendErrorMaxRetry) return h.logger.log(\"fail \" + e.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\"), r = [], n.fatal = !0, void e.trigger(u.default.ERROR, n);\n                        n.fatal = !1, e.trigger(u.default.ERROR, n);\n                      }\n                    }\n                  }\n                }\n              }, {\n                key: \"flushBuffer\",\n                value: function value(e, t, r) {\n                  var i,\n                      a,\n                      n,\n                      s,\n                      o,\n                      l,\n                      u = this.sourceBuffer;\n\n                  if (Object.keys(u).length) {\n                    if (h.logger.log(\"flushBuffer,pos/start/end: \" + this.media.currentTime + \"/\" + e + \"/\" + t), this.appended > this.flushBufferCounter) {\n                      for (var d in u) {\n                        if (!r || d === r) {\n                          if (i = u[d], i.ended = !1, i.updating) return h.logger.warn(\"cannot flush, sb updating in progress\"), !1;\n\n                          try {\n                            for (a = 0; i.buffered.length > a; a++) {\n                              if (n = i.buffered.start(a), s = i.buffered.end(a), navigator.userAgent.toLowerCase().indexOf(\"firefox\") !== -1 && t === Number.POSITIVE_INFINITY ? (o = e, l = t) : (o = Math.max(n, e), l = Math.min(s, t)), Math.min(l, s) - o > .5) return this.flushBufferCounter++, h.logger.log(\"flush \" + d + \" [\" + o + \",\" + l + \"], of [\" + n + \",\" + s + \"], pos:\" + this.media.currentTime), i.remove(o, l), !1;\n                            }\n                          } catch (e) {\n                            h.logger.warn(\"exception while accessing sourcebuffer, it might have been removed from MediaSource\");\n                          }\n                        }\n                      }\n                    } else h.logger.warn(\"abort flushing too many retries\");\n\n                    h.logger.log(\"buffer flushed\");\n                  }\n\n                  return !0;\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = v;\n          }, {\n            26: 26,\n            27: 27,\n            28: 28,\n            45: 45\n          }],\n          8: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = function (e) {\n              function t(e) {\n                return a(this, t), n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.FPS_DROP_LEVEL_CAPPING, u.default.MEDIA_ATTACHING, u.default.MANIFEST_PARSED));\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.hls.config.capLevelToPlayerSize && (this.media = this.restrictedLevels = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer)));\n                }\n              }, {\n                key: \"onFpsDropLevelCapping\",\n                value: function value(e) {\n                  this.restrictedLevels || (this.restrictedLevels = []), this.isLevelRestricted(e.droppedLevel) || this.restrictedLevels.push(e.droppedLevel);\n                }\n              }, {\n                key: \"onMediaAttaching\",\n                value: function value(e) {\n                  this.media = e.media instanceof HTMLVideoElement ? e.media : null;\n                }\n              }, {\n                key: \"onManifestParsed\",\n                value: function value(e) {\n                  this.hls.config.capLevelToPlayerSize && (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.levels = e.levels, this.hls.firstLevel = this.getMaxLevel(e.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());\n                }\n              }, {\n                key: \"detectPlayerSize\",\n                value: function value() {\n                  if (this.media) {\n                    var e = this.levels ? this.levels.length : 0;\n                    e && (this.hls.autoLevelCapping = this.getMaxLevel(e - 1), this.hls.autoLevelCapping > this.autoLevelCapping && this.hls.streamController.nextLevelSwitch(), this.autoLevelCapping = this.hls.autoLevelCapping);\n                  }\n                }\n              }, {\n                key: \"getMaxLevel\",\n                value: function value(e) {\n                  var t = 0,\n                      r = void 0,\n                      i = void 0,\n                      a = this.mediaWidth,\n                      n = this.mediaHeight,\n                      s = 0,\n                      o = 0;\n\n                  for (r = 0; e >= r && (i = this.levels[r], !this.isLevelRestricted(r)) && (t = r, s = i.width, o = i.height, s < a && o < n); r++) {\n                    ;\n                  }\n\n                  return t;\n                }\n              }, {\n                key: \"isLevelRestricted\",\n                value: function value(e) {\n                  return !(!this.restrictedLevels || this.restrictedLevels.indexOf(e) === -1);\n                }\n              }, {\n                key: \"contentScaleFactor\",\n                get: function get() {\n                  var e = 1;\n\n                  try {\n                    e = window.devicePixelRatio;\n                  } catch (e) {}\n\n                  return e;\n                }\n              }, {\n                key: \"mediaWidth\",\n                get: function get() {\n                  var e = void 0;\n                  return this.media && (e = this.media.width || this.media.clientWidth || this.media.offsetWidth, e *= this.contentScaleFactor), e;\n                }\n              }, {\n                key: \"mediaHeight\",\n                get: function get() {\n                  var e = void 0;\n                  return this.media && (e = this.media.height || this.media.clientHeight || this.media.offsetHeight, e *= this.contentScaleFactor), e;\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = h;\n          }, {\n            27: 27,\n            28: 28\n          }],\n          9: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(44),\n                o = i(s),\n                l = function () {\n              function e(t, r, i, n) {\n                a(this, e), this.hls = t, this.defaultEstimate_ = n, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new o.default(r), this.fast_ = new o.default(i);\n              }\n\n              return n(e, [{\n                key: \"sample\",\n                value: function value(e, t) {\n                  e = Math.max(e, this.minDelayMs_);\n                  var r = 8e3 * t / e,\n                      i = e / 1e3;\n                  this.fast_.sample(i, r), this.slow_.sample(i, r);\n                }\n              }, {\n                key: \"canEstimate\",\n                value: function value() {\n                  var e = this.fast_;\n                  return e && e.getTotalWeight() >= this.minWeight_;\n                }\n              }, {\n                key: \"getEstimate\",\n                value: function value() {\n                  return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;\n                }\n              }, {\n                key: \"destroy\",\n                value: function value() {}\n              }]), e;\n            }();\n\n            r.default = l;\n          }, {\n            44: 44\n          }],\n          10: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(45),\n                c = function (e) {\n              function t(e) {\n                return a(this, t), n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.MEDIA_ATTACHING));\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1;\n                }\n              }, {\n                key: \"onMediaAttaching\",\n                value: function value(e) {\n                  this.hls.config.capLevelOnFPSDrop && (this.video = e.media instanceof HTMLVideoElement ? e.media : null, \"function\" == typeof this.video.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), this.hls.config.fpsDroppedMonitoringPeriod));\n                }\n              }, {\n                key: \"checkFPS\",\n                value: function value(e, t, r) {\n                  var i = performance.now();\n\n                  if (t) {\n                    if (this.lastTime) {\n                      var a = i - this.lastTime,\n                          n = r - this.lastDroppedFrames,\n                          s = t - this.lastDecodedFrames,\n                          o = 1e3 * n / a;\n\n                      if (this.hls.trigger(u.default.FPS_DROP, {\n                        currentDropped: n,\n                        currentDecoded: s,\n                        totalDroppedFrames: r\n                      }), o > 0 && n > this.hls.config.fpsDroppedMonitoringThreshold * s) {\n                        var l = this.hls.currentLevel;\n                        h.logger.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + l), 0 >= l || this.hls.autoLevelCapping !== -1 && l > this.hls.autoLevelCapping || (l -= 1, this.hls.trigger(u.default.FPS_DROP_LEVEL_CAPPING, {\n                          level: l,\n                          droppedLevel: this.hls.currentLevel\n                        }), this.hls.autoLevelCapping = l, this.hls.streamController.nextLevelSwitch());\n                      }\n                    }\n\n                    this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = t;\n                  }\n                }\n              }, {\n                key: \"checkFPSInterval\",\n                value: function value() {\n                  if (this.video) if (this.isVideoPlaybackQualityAvailable) {\n                    var e = this.video.getVideoPlaybackQuality();\n                    this.checkFPS(this.video, e.totalVideoFrames, e.droppedVideoFrames);\n                  } else this.checkFPS(this.video, this.video.webkitDecodedFrameCount, this.video.webkitDroppedFrameCount);\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = c;\n          }, {\n            27: 27,\n            28: 28,\n            45: 45\n          }],\n          11: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(45),\n                c = e(26),\n                v = e(30),\n                g = i(v),\n                p = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.MANIFEST_LOADED, u.default.LEVEL_LOADED, u.default.ERROR));\n                return r.ontick = r.tick.bind(r), r._manualLevel = r._autoLevelCapping = -1, r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.timer && (clearTimeout(this.timer), this.timer = null), this._manualLevel = -1;\n                }\n              }, {\n                key: \"startLoad\",\n                value: function value() {\n                  this.canload = !0, this.timer && this.tick();\n                }\n              }, {\n                key: \"stopLoad\",\n                value: function value() {\n                  this.canload = !1;\n                }\n              }, {\n                key: \"onManifestLoaded\",\n                value: function value(e) {\n                  var t,\n                      r = [],\n                      i = [],\n                      a = {},\n                      n = !1,\n                      s = !1,\n                      o = this.hls,\n                      l = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),\n                      d = function d(e, t) {\n                    return MediaSource.isTypeSupported(e + \"/mp4;codecs=\" + t);\n                  };\n\n                  if (e.levels.forEach(function (e) {\n                    e.videoCodec && (n = !0), l && e.audioCodec && e.audioCodec.indexOf(\"mp4a.40.34\") !== -1 && (e.audioCodec = void 0), (e.audioCodec || e.attrs && e.attrs.AUDIO) && (s = !0);\n                    var t = a[e.bitrate];\n                    void 0 === t ? (a[e.bitrate] = r.length, e.url = [e.url], e.urlId = 0, r.push(e)) : r[t].url.push(e.url);\n                  }), n && s ? r.forEach(function (e) {\n                    e.videoCodec && i.push(e);\n                  }) : i = r, i = i.filter(function (e) {\n                    var t = e.audioCodec,\n                        r = e.videoCodec;\n                    return (!t || d(\"audio\", t)) && (!r || d(\"video\", r));\n                  }), i.length) {\n                    t = i[0].bitrate, i.sort(function (e, t) {\n                      return e.bitrate - t.bitrate;\n                    }), this._levels = i;\n\n                    for (var f = 0; i.length > f; f++) {\n                      if (i[f].bitrate === t) {\n                        this._firstLevel = f, h.logger.log(\"manifest loaded,\" + i.length + \" level(s) found, first bitrate:\" + t);\n                        break;\n                      }\n                    }\n\n                    o.trigger(u.default.MANIFEST_PARSED, {\n                      levels: i,\n                      firstLevel: this._firstLevel,\n                      stats: e.stats,\n                      audio: s,\n                      video: n,\n                      altAudio: e.audioTracks.length > 0\n                    });\n                  } else o.trigger(u.default.ERROR, {\n                    type: c.ErrorTypes.MEDIA_ERROR,\n                    details: c.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n                    fatal: !0,\n                    url: o.url,\n                    reason: \"no level with compatible codecs found in manifest\"\n                  });\n                }\n              }, {\n                key: \"setLevelInternal\",\n                value: function value(e) {\n                  var t = this._levels;\n\n                  if (e >= 0 && t.length > e) {\n                    this.timer && (clearTimeout(this.timer), this.timer = null), this._level !== e && (h.logger.log(\"switching to level \" + e), this._level = e, this.hls.trigger(u.default.LEVEL_SWITCH, {\n                      level: e\n                    }));\n                    var r = t[e],\n                        i = r.details;\n\n                    if (!i || i.live === !0) {\n                      var a = r.urlId;\n                      this.hls.trigger(u.default.LEVEL_LOADING, {\n                        url: r.url[a],\n                        level: e,\n                        id: a\n                      });\n                    }\n                  } else this.hls.trigger(u.default.ERROR, {\n                    type: c.ErrorTypes.OTHER_ERROR,\n                    details: c.ErrorDetails.LEVEL_SWITCH_ERROR,\n                    level: e,\n                    fatal: !1,\n                    reason: \"invalid level idx\"\n                  });\n                }\n              }, {\n                key: \"onError\",\n                value: function value(e) {\n                  if (!e.fatal) {\n                    var t = e.details,\n                        r = this.hls,\n                        i = void 0,\n                        a = void 0,\n                        n = !1,\n                        s = r.abrController,\n                        o = s.minAutoLevel;\n\n                    switch (t) {\n                      case c.ErrorDetails.FRAG_LOAD_ERROR:\n                      case c.ErrorDetails.FRAG_LOAD_TIMEOUT:\n                      case c.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n                      case c.ErrorDetails.KEY_LOAD_ERROR:\n                      case c.ErrorDetails.KEY_LOAD_TIMEOUT:\n                        i = e.frag.level;\n                        break;\n\n                      case c.ErrorDetails.LEVEL_LOAD_ERROR:\n                      case c.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n                        i = e.context.level, n = !0;\n                        break;\n\n                      case c.ErrorDetails.REMUX_ALLOC_ERROR:\n                        i = e.level;\n                    }\n\n                    if (void 0 !== i) if (a = this._levels[i], a.url.length - 1 > a.urlId) a.urlId++, a.details = void 0, h.logger.warn(\"level controller,\" + t + \" for level \" + i + \": switching to redundant stream id \" + a.urlId);else {\n                      var l = this._manualLevel === -1 && i;\n                      if (l) h.logger.warn(\"level controller,\" + t + \": switch-down for next fragment\"), s.nextAutoLevel = Math.max(o, i - 1);else if (a && a.details && a.details.live) h.logger.warn(\"level controller,\" + t + \" on live stream, discard\"), n && (this._level = void 0);else if (t === c.ErrorDetails.LEVEL_LOAD_ERROR || t === c.ErrorDetails.LEVEL_LOAD_TIMEOUT) {\n                        var d = r.media,\n                            f = d && g.default.isBuffered(d, d.currentTime) && g.default.isBuffered(d, d.currentTime + .5);\n\n                        if (f) {\n                          var v = r.config.levelLoadingRetryDelay;\n                          h.logger.warn(\"level controller,\" + t + \", but media buffered, retry in \" + v + \"ms\"), this.timer = setTimeout(this.ontick, v);\n                        } else h.logger.error(\"cannot recover \" + t + \" error\"), this._level = void 0, this.timer && (clearTimeout(this.timer), this.timer = null), e.fatal = !0, r.trigger(u.default.ERROR, e);\n                      }\n                    }\n                  }\n                }\n              }, {\n                key: \"onLevelLoaded\",\n                value: function value(e) {\n                  if (e.level === this._level) {\n                    var t = e.details;\n\n                    if (t.live) {\n                      var r = 1e3 * (t.averagetargetduration ? t.averagetargetduration : t.targetduration),\n                          i = this._levels[e.level],\n                          a = i.details;\n                      a && t.endSN === a.endSN && (r /= 2, h.logger.log(\"same live playlist, reload twice faster\")), r -= performance.now() - e.stats.trequest, r = Math.max(1e3, Math.round(r)), h.logger.log(\"live playlist, reload in \" + r + \" ms\"), this.timer = setTimeout(this.ontick, r);\n                    } else this.timer = null;\n                  }\n                }\n              }, {\n                key: \"tick\",\n                value: function value() {\n                  var e = this._level;\n\n                  if (void 0 !== e && this.canload) {\n                    var t = this._levels[e],\n                        r = t.urlId;\n                    this.hls.trigger(u.default.LEVEL_LOADING, {\n                      url: t.url[r],\n                      level: e,\n                      id: r\n                    });\n                  }\n                }\n              }, {\n                key: \"levels\",\n                get: function get() {\n                  return this._levels;\n                }\n              }, {\n                key: \"level\",\n                get: function get() {\n                  return this._level;\n                },\n                set: function set(e) {\n                  var t = this._levels;\n                  t && t.length > e && (this._level === e && void 0 !== t[e].details || this.setLevelInternal(e));\n                }\n              }, {\n                key: \"manualLevel\",\n                get: function get() {\n                  return this._manualLevel;\n                },\n                set: function set(e) {\n                  this._manualLevel = e, void 0 === this._startLevel && (this._startLevel = e), e !== -1 && (this.level = e);\n                }\n              }, {\n                key: \"firstLevel\",\n                get: function get() {\n                  return this._firstLevel;\n                },\n                set: function set(e) {\n                  this._firstLevel = e;\n                }\n              }, {\n                key: \"startLevel\",\n                get: function get() {\n                  if (void 0 === this._startLevel) {\n                    var e = this.hls.config.startLevel;\n                    return void 0 !== e ? e : this._firstLevel;\n                  }\n\n                  return this._startLevel;\n                },\n                set: function set(e) {\n                  e !== -1 && (e = Math.max(e, this.hls.abrController.minAutoLevel)), this._startLevel = e;\n                }\n              }, {\n                key: \"nextLoadLevel\",\n                get: function get() {\n                  return this._manualLevel !== -1 ? this._manualLevel : this.hls.abrController.nextAutoLevel;\n                },\n                set: function set(e) {\n                  this.level = e, this._manualLevel === -1 && (this.hls.abrController.nextAutoLevel = e);\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = p;\n          }, {\n            26: 26,\n            27: 27,\n            28: 28,\n            30: 30,\n            45: 45\n          }],\n          12: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(41),\n                u = i(l),\n                d = e(30),\n                f = i(d),\n                h = e(22),\n                c = i(h),\n                v = e(28),\n                g = i(v),\n                p = e(27),\n                y = i(p),\n                m = e(31),\n                E = i(m),\n                b = e(46),\n                R = i(b),\n                _ = e(26),\n                k = e(45),\n                T = {\n              STOPPED: \"STOPPED\",\n              IDLE: \"IDLE\",\n              KEY_LOADING: \"KEY_LOADING\",\n              FRAG_LOADING: \"FRAG_LOADING\",\n              FRAG_LOADING_WAITING_RETRY: \"FRAG_LOADING_WAITING_RETRY\",\n              WAITING_LEVEL: \"WAITING_LEVEL\",\n              PARSING: \"PARSING\",\n              PARSED: \"PARSED\",\n              BUFFER_FLUSHING: \"BUFFER_FLUSHING\",\n              ENDED: \"ENDED\",\n              ERROR: \"ERROR\"\n            },\n                A = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, g.default.MEDIA_ATTACHED, g.default.MEDIA_DETACHING, g.default.MANIFEST_LOADING, g.default.MANIFEST_PARSED, g.default.LEVEL_LOADED, g.default.KEY_LOADED, g.default.FRAG_LOADED, g.default.FRAG_LOAD_EMERGENCY_ABORTED, g.default.FRAG_PARSING_INIT_SEGMENT, g.default.FRAG_PARSING_DATA, g.default.FRAG_PARSED, g.default.ERROR, g.default.AUDIO_TRACK_SWITCH, g.default.BUFFER_CREATED, g.default.BUFFER_APPENDED, g.default.BUFFER_FLUSHED));\n                return r.config = e.config, r.audioCodecSwap = !1, r.ticks = 0, r.ontick = r.tick.bind(r), r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), y.default.prototype.destroy.call(this), this.state = T.STOPPED;\n                }\n              }, {\n                key: \"startLoad\",\n                value: function value(e) {\n                  if (this.levels) {\n                    var t = this.lastCurrentTime,\n                        r = this.hls;\n\n                    if (this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {\n                      var i = r.startLevel;\n                      i === -1 && (i = 0, this.bitrateTest = !0), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1;\n                    }\n\n                    t > 0 && e === -1 && (k.logger.log(\"override startPosition with lastCurrentTime @\" + t.toFixed(3)), e = t), this.state = T.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick();\n                  } else k.logger.warn(\"cannot start loading as manifest not parsed yet\"), this.state = T.STOPPED;\n                }\n              }, {\n                key: \"stopLoad\",\n                value: function value() {\n                  var e = this.fragCurrent;\n                  e && (e.loader && e.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = T.STOPPED;\n                }\n              }, {\n                key: \"tick\",\n                value: function value() {\n                  this.ticks++, 1 === this.ticks && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);\n                }\n              }, {\n                key: \"doTick\",\n                value: function value() {\n                  switch (this.state) {\n                    case T.ERROR:\n                      break;\n\n                    case T.BUFFER_FLUSHING:\n                      this.fragLoadError = 0;\n                      break;\n\n                    case T.IDLE:\n                      if (!this._doTickIdle()) return;\n                      break;\n\n                    case T.WAITING_LEVEL:\n                      var e = this.levels[this.level];\n                      e && e.details && (this.state = T.IDLE);\n                      break;\n\n                    case T.FRAG_LOADING_WAITING_RETRY:\n                      var t = performance.now(),\n                          r = this.retryDate;\n                      (!r || t >= r || this.media && this.media.seeking) && (k.logger.log(\"mediaController: retryDate reached, switch back to IDLE state\"), this.state = T.IDLE);\n                      break;\n\n                    case T.ERROR:\n                    case T.PAUSED:\n                    case T.STOPPED:\n                    case T.FRAG_LOADING:\n                    case T.PARSING:\n                    case T.PARSED:\n                    case T.ENDED:\n                  }\n\n                  this._checkBuffer(), this._checkFragmentChanged();\n                }\n              }, {\n                key: \"_doTickIdle\",\n                value: function value() {\n                  var e = this.hls,\n                      t = e.config,\n                      r = this.media;\n                  if (void 0 !== this.levelLastLoaded && !r && (this.startFragRequested || !t.startFragPrefetch)) return !0;\n                  var i = void 0;\n                  i = this.loadedmetadata ? r.currentTime : this.nextLoadPosition;\n                  var a = e.nextLoadLevel,\n                      n = this.levels[a],\n                      s = n.bitrate,\n                      o = void 0;\n                  o = s ? Math.max(8 * t.maxBufferSize / s, t.maxBufferLength) : t.maxBufferLength, o = Math.min(o, t.maxMaxBufferLength);\n                  var l = f.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : r, i, t.maxBufferHole),\n                      u = l.len;\n                  if (u >= o) return !0;\n                  k.logger.trace(\"buffer length of \" + u.toFixed(3) + \" is below max of \" + o.toFixed(3) + \". checking for more payload ...\"), this.level = e.nextLoadLevel = a;\n                  var d = n.details;\n                  if (void 0 === d || d.live && this.levelLastLoaded !== a) return this.state = T.WAITING_LEVEL, !0;\n                  var h = this.fragPrevious;\n\n                  if (!d.live && h && h.sn === d.endSN && (!r.seeking && l.len || h.duration / 2 >= r.duration - l.end)) {\n                    var c = {};\n                    return this.altAudio && (c.type = \"video\"), this.hls.trigger(g.default.BUFFER_EOS, c), this.state = T.ENDED, !0;\n                  }\n\n                  return this._fetchPayloadOrEos({\n                    pos: i,\n                    bufferInfo: l,\n                    levelDetails: d\n                  });\n                }\n              }, {\n                key: \"_fetchPayloadOrEos\",\n                value: function value(e) {\n                  var t = e.pos,\n                      r = e.bufferInfo,\n                      i = e.levelDetails,\n                      a = this.fragPrevious,\n                      n = this.level,\n                      s = i.fragments,\n                      o = s.length;\n                  if (0 === o) return !1;\n                  var l = s[0].start,\n                      u = s[o - 1].start + s[o - 1].duration,\n                      d = r.end,\n                      f = void 0;\n\n                  if (i.live) {\n                    var h = this.config.initialLiveManifestSize;\n                    if (h > o) return k.logger.warn(\"Can not start playback of a level, reason: not enough fragments \" + o + \" < \" + h), !1;\n                    if (f = this._ensureFragmentAtLivePoint({\n                      levelDetails: i,\n                      bufferEnd: d,\n                      start: l,\n                      end: u,\n                      fragPrevious: a,\n                      fragments: s,\n                      fragLen: o\n                    }), null === f) return !1;\n                  } else l > d && (f = s[0]);\n\n                  return f || (f = this._findFragment({\n                    start: l,\n                    fragPrevious: a,\n                    fragLen: o,\n                    fragments: s,\n                    bufferEnd: d,\n                    end: u,\n                    levelDetails: i\n                  })), !f || this._loadFragmentOrKey({\n                    frag: f,\n                    level: n,\n                    levelDetails: i,\n                    pos: t,\n                    bufferEnd: d\n                  });\n                }\n              }, {\n                key: \"_ensureFragmentAtLivePoint\",\n                value: function value(e) {\n                  var t = e.levelDetails,\n                      r = e.bufferEnd,\n                      i = e.start,\n                      a = e.end,\n                      n = e.fragPrevious,\n                      s = e.fragments,\n                      o = e.fragLen,\n                      l = this.hls.config,\n                      u = this.media,\n                      d = void 0,\n                      f = void 0 !== l.liveMaxLatencyDuration ? l.liveMaxLatencyDuration : l.liveMaxLatencyDurationCount * t.targetduration;\n\n                  if (r < Math.max(i, a - f)) {\n                    var h = this.liveSyncPosition = this.computeLivePosition(i, t);\n                    k.logger.log(\"buffer end: \" + r.toFixed(3) + \" is located too far from the end of live sliding playlist, reset currentTime to : \" + h.toFixed(3)), r = h, u && u.readyState && u.duration > h && (u.currentTime = h);\n                  }\n\n                  if (t.PTSKnown && r > a && u && u.readyState) return null;\n\n                  if (this.startFragRequested && !t.PTSKnown) {\n                    if (n) {\n                      var c = n.sn + 1;\n                      t.startSN > c || c > t.endSN || (d = s[c - t.startSN], k.logger.log(\"live playlist, switching playlist, load frag with next SN: \" + d.sn));\n                    }\n\n                    d || (d = s[Math.min(o - 1, Math.round(o / 2))], k.logger.log(\"live playlist, switching playlist, unknown, load middle frag : \" + d.sn));\n                  }\n\n                  return d;\n                }\n              }, {\n                key: \"_findFragment\",\n                value: function value(e) {\n                  var t = e.start,\n                      r = e.fragPrevious,\n                      i = e.fragLen,\n                      a = e.fragments,\n                      n = e.bufferEnd,\n                      s = e.end,\n                      o = e.levelDetails,\n                      l = this.hls.config,\n                      d = void 0,\n                      f = void 0,\n                      h = l.maxFragLookUpTolerance;\n                  if (s > n ? (n > s - h && (h = 0), f = u.default.search(a, function (e) {\n                    return e.start + e.duration - h > n ? e.start - h > n && e.start ? -1 : 0 : 1;\n                  })) : f = a[i - 1], f && (d = f, t = f.start, r && d.level === r.level && d.sn === r.sn)) if (o.endSN > d.sn) {\n                    var c = r.deltaPTS,\n                        v = d.sn - o.startSN;\n                    c && c > l.maxBufferHole && r.dropped && v ? (d = a[v - 1], k.logger.warn(\"SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this\"), r.loadCounter--) : (d = a[v + 1], k.logger.log(\"SN just loaded, load next one: \" + d.sn));\n                  } else d = null;\n                  return d;\n                }\n              }, {\n                key: \"_loadFragmentOrKey\",\n                value: function value(e) {\n                  var t = e.frag,\n                      r = e.level,\n                      i = e.levelDetails,\n                      a = e.pos,\n                      n = e.bufferEnd,\n                      s = this.hls,\n                      o = s.config;\n\n                  if (null == t.decryptdata.uri || null != t.decryptdata.key) {\n                    if (k.logger.log(\"Loading \" + t.sn + \" of [\" + i.startSN + \" ,\" + i.endSN + \"],level \" + r + \", currentTime:\" + a.toFixed(3) + \",bufferEnd:\" + n.toFixed(3)), void 0 !== this.fragLoadIdx ? this.fragLoadIdx++ : this.fragLoadIdx = 0, t.loadCounter) {\n                      t.loadCounter++;\n                      var l = o.fragLoadingLoopThreshold;\n                      if (t.loadCounter > l && Math.abs(this.fragLoadIdx - t.loadIdx) < l) return s.trigger(g.default.ERROR, {\n                        type: _.ErrorTypes.MEDIA_ERROR,\n                        details: _.ErrorDetails.FRAG_LOOP_LOADING_ERROR,\n                        fatal: !1,\n                        frag: t\n                      }), !1;\n                    } else t.loadCounter = 1;\n\n                    return t.loadIdx = this.fragLoadIdx, this.fragCurrent = t, this.startFragRequested = !0, this.nextLoadPosition = t.start + t.duration, t.autoLevel = s.autoLevelEnabled, t.bitrateTest = this.bitrateTest, s.trigger(g.default.FRAG_LOADING, {\n                      frag: t\n                    }), this.demuxer || (this.demuxer = new c.default(s, \"main\")), this.state = T.FRAG_LOADING, !0;\n                  }\n\n                  k.logger.log(\"Loading key for \" + t.sn + \" of [\" + i.startSN + \" ,\" + i.endSN + \"],level \" + r), this.state = T.KEY_LOADING, s.trigger(g.default.KEY_LOADING, {\n                    frag: t\n                  });\n                }\n              }, {\n                key: \"getBufferRange\",\n                value: function value(e) {\n                  var t,\n                      r,\n                      i = this.bufferRange;\n                  if (i) for (t = i.length - 1; t >= 0; t--) {\n                    if (r = i[t], e >= r.start && r.end >= e) return r;\n                  }\n                  return null;\n                }\n              }, {\n                key: \"followingBufferRange\",\n                value: function value(e) {\n                  return e ? this.getBufferRange(e.end + .5) : null;\n                }\n              }, {\n                key: \"_checkFragmentChanged\",\n                value: function value() {\n                  var e,\n                      t,\n                      r = this.media;\n\n                  if (r && r.readyState && r.seeking === !1 && (t = r.currentTime, t > r.playbackRate * this.lastCurrentTime && (this.lastCurrentTime = t), f.default.isBuffered(r, t) ? e = this.getBufferRange(t) : f.default.isBuffered(r, t + .1) && (e = this.getBufferRange(t + .1)), e)) {\n                    var i = e.frag;\n                    i !== this.fragPlaying && (this.fragPlaying = i, this.hls.trigger(g.default.FRAG_CHANGED, {\n                      frag: i\n                    }));\n                  }\n                }\n              }, {\n                key: \"immediateLevelSwitch\",\n                value: function value() {\n                  if (k.logger.log(\"immediateLevelSwitch\"), !this.immediateSwitch) {\n                    this.immediateSwitch = !0;\n                    var e = this.media,\n                        t = void 0;\n                    e ? (t = e.paused, e.pause()) : t = !0, this.previouslyPaused = t;\n                  }\n\n                  var r = this.fragCurrent;\n                  r && r.loader && r.loader.abort(), this.fragCurrent = null, this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, this.state = T.BUFFER_FLUSHING, this.hls.trigger(g.default.BUFFER_FLUSHING, {\n                    startOffset: 0,\n                    endOffset: Number.POSITIVE_INFINITY\n                  });\n                }\n              }, {\n                key: \"immediateLevelSwitchEnd\",\n                value: function value() {\n                  var e = this.media;\n                  e && e.buffered.length && (this.immediateSwitch = !1, f.default.isBuffered(e, e.currentTime) && (e.currentTime -= 1e-4), this.previouslyPaused || e.play());\n                }\n              }, {\n                key: \"nextLevelSwitch\",\n                value: function value() {\n                  var e = this.media;\n\n                  if (e && e.readyState) {\n                    var t = void 0,\n                        r = void 0,\n                        i = void 0;\n                    if (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, r = this.getBufferRange(e.currentTime), r && r.start > 1 && (this.state = T.BUFFER_FLUSHING, this.hls.trigger(g.default.BUFFER_FLUSHING, {\n                      startOffset: 0,\n                      endOffset: r.start - 1\n                    })), e.paused) t = 0;else {\n                      var a = this.hls.nextLoadLevel,\n                          n = this.levels[a],\n                          s = this.fragLastKbps;\n                      t = s && this.fragCurrent ? this.fragCurrent.duration * n.bitrate / (1e3 * s) + 1 : 0;\n                    }\n\n                    if (i = this.getBufferRange(e.currentTime + t), i && (i = this.followingBufferRange(i))) {\n                      var o = this.fragCurrent;\n                      o && o.loader && o.loader.abort(), this.fragCurrent = null, this.state = T.BUFFER_FLUSHING, this.hls.trigger(g.default.BUFFER_FLUSHING, {\n                        startOffset: i.start,\n                        endOffset: Number.POSITIVE_INFINITY\n                      });\n                    }\n                  }\n                }\n              }, {\n                key: \"onMediaAttached\",\n                value: function value(e) {\n                  var t = this.media = this.mediaBuffer = e.media;\n                  this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener(\"seeking\", this.onvseeking), t.addEventListener(\"seeked\", this.onvseeked), t.addEventListener(\"ended\", this.onvended);\n                  var r = this.config;\n                  this.levels && r.autoStartLoad && this.hls.startLoad(r.startPosition);\n                }\n              }, {\n                key: \"onMediaDetaching\",\n                value: function value() {\n                  var e = this.media;\n                  e && e.ended && (k.logger.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0);\n                  var t = this.levels;\n                  t && t.forEach(function (e) {\n                    e.details && e.details.fragments.forEach(function (e) {\n                      e.loadCounter = void 0;\n                    });\n                  }), e && (e.removeEventListener(\"seeking\", this.onvseeking), e.removeEventListener(\"seeked\", this.onvseeked), e.removeEventListener(\"ended\", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad();\n                }\n              }, {\n                key: \"onMediaSeeking\",\n                value: function value() {\n                  var e = this.media,\n                      t = e ? e.currentTime : void 0,\n                      r = this.config;\n\n                  if (k.logger.log(\"media seeking to \" + t.toFixed(3)), this.state === T.FRAG_LOADING) {\n                    var i = f.default.bufferInfo(e, t, this.config.maxBufferHole),\n                        a = this.fragCurrent;\n\n                    if (0 === i.len && a) {\n                      var n = r.maxFragLookUpTolerance,\n                          s = a.start - n,\n                          o = a.start + a.duration + n;\n                      s > t || t > o ? (a.loader && (k.logger.log(\"seeking outside of buffer while fragment load in progress, cancel fragment load\"), a.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = T.IDLE) : k.logger.log(\"seeking outside of buffer but within currently loaded fragment range\");\n                    }\n                  } else this.state === T.ENDED && (this.state = T.IDLE);\n\n                  e && (this.lastCurrentTime = t), this.state !== T.FRAG_LOADING && void 0 !== this.fragLoadIdx && (this.fragLoadIdx += 2 * r.fragLoadingLoopThreshold), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = t), this.tick();\n                }\n              }, {\n                key: \"onMediaSeeked\",\n                value: function value() {\n                  k.logger.log(\"media seeked to \" + this.media.currentTime.toFixed(3)), this.tick();\n                }\n              }, {\n                key: \"onMediaEnded\",\n                value: function value() {\n                  k.logger.log(\"media ended\"), this.startPosition = this.lastCurrentTime = 0;\n                }\n              }, {\n                key: \"onManifestLoading\",\n                value: function value() {\n                  k.logger.log(\"trigger BUFFER_RESET\"), this.hls.trigger(g.default.BUFFER_RESET), this.bufferRange = [], this.stalled = !1, this.startPosition = this.lastCurrentTime = 0;\n                }\n              }, {\n                key: \"onManifestParsed\",\n                value: function value(e) {\n                  var t,\n                      r = !1,\n                      i = !1;\n                  e.levels.forEach(function (e) {\n                    t = e.audioCodec, t && (t.indexOf(\"mp4a.40.2\") !== -1 && (r = !0), t.indexOf(\"mp4a.40.5\") !== -1 && (i = !0));\n                  }), this.audioCodecSwitch = r && i, this.audioCodecSwitch && k.logger.log(\"both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\"), this.levels = e.levels, this.startLevelLoaded = !1, this.startFragRequested = !1;\n                  var a = this.config;\n                  a.autoStartLoad && this.hls.startLoad(a.startPosition);\n                }\n              }, {\n                key: \"onLevelLoaded\",\n                value: function value(e) {\n                  var t = e.details,\n                      r = e.level,\n                      i = this.levels[r],\n                      a = t.totalduration,\n                      n = 0;\n\n                  if (k.logger.log(\"level \" + r + \" loaded [\" + t.startSN + \",\" + t.endSN + \"],duration:\" + a), this.levelLastLoaded = r, t.live) {\n                    var s = i.details;\n                    s && t.fragments.length > 0 ? (E.default.mergeDetails(s, t), n = t.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(n, s), k.logger.log(t.PTSKnown ? \"live playlist sliding:\" + n.toFixed(3) : \"live playlist - outdated PTS, unknown sliding\")) : (t.PTSKnown = !1, k.logger.log(\"live playlist - first load, unknown sliding\"));\n                  } else t.PTSKnown = !1;\n\n                  if (i.details = t, this.hls.trigger(g.default.LEVEL_UPDATED, {\n                    details: t,\n                    level: r\n                  }), this.startFragRequested === !1) {\n                    if (this.startPosition === -1 || this.lastCurrentTime === -1) {\n                      var o = t.startTimeOffset;\n                      isNaN(o) ? t.live ? (this.startPosition = this.computeLivePosition(n, t), k.logger.log(\"configure startPosition to \" + this.startPosition)) : this.startPosition = 0 : (0 > o && (k.logger.log(\"negative start time offset \" + o + \", count from end of last fragment\"), o = n + a + o), k.logger.log(\"start time offset found in playlist, adjust startPosition to \" + o), this.startPosition = o), this.lastCurrentTime = this.startPosition;\n                    }\n\n                    this.nextLoadPosition = this.startPosition;\n                  }\n\n                  this.state === T.WAITING_LEVEL && (this.state = T.IDLE), this.tick();\n                }\n              }, {\n                key: \"onKeyLoaded\",\n                value: function value() {\n                  this.state === T.KEY_LOADING && (this.state = T.IDLE, this.tick());\n                }\n              }, {\n                key: \"onFragLoaded\",\n                value: function value(e) {\n                  var t = this.fragCurrent,\n                      r = e.frag;\n\n                  if (this.state === T.FRAG_LOADING && t && \"main\" === r.type && r.level === t.level && r.sn === t.sn) {\n                    var i = e.stats,\n                        a = this.levels[t.level],\n                        n = a.details;\n                    if (k.logger.log(\"Loaded  \" + t.sn + \" of [\" + n.startSN + \" ,\" + n.endSN + \"],level \" + t.level), this.bitrateTest = !1, r.bitrateTest === !0 && this.hls.nextLoadLevel) this.state = T.IDLE, this.startFragRequested = !1, i.tparsed = i.tbuffered = performance.now(), this.hls.trigger(g.default.FRAG_BUFFERED, {\n                      stats: i,\n                      frag: t,\n                      id: \"main\"\n                    }), this.tick();else {\n                      this.state = T.PARSING, this.stats = i;\n                      var s = n.totalduration,\n                          o = isNaN(t.startDTS) ? t.start : t.startDTS,\n                          l = t.level,\n                          u = t.sn,\n                          d = this.config.defaultAudioCodec || a.audioCodec;\n                      this.audioCodecSwap && (k.logger.log(\"swapping playlist audio codec\"), void 0 === d && (d = this.lastAudioCodec), d && (d = d.indexOf(\"mp4a.40.5\") !== -1 ? \"mp4a.40.2\" : \"mp4a.40.5\")), this.pendingAppending = 0, k.logger.log(\"Parsing \" + u + \" of [\" + n.startSN + \" ,\" + n.endSN + \"],level \" + l + \", cc \" + t.cc);\n                      var f = this.demuxer;\n                      f || (f = this.demuxer = new c.default(this.hls, \"main\"));\n                      var h = n.PTSKnown || !n.live;\n                      f.push(e.payload, d, a.videoCodec, o, t.cc, l, u, s, t.decryptdata, h);\n                    }\n                  }\n\n                  this.fragLoadError = 0;\n                }\n              }, {\n                key: \"onFragParsingInitSegment\",\n                value: function value(e) {\n                  var t = this.fragCurrent;\n\n                  if (t && \"main\" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING) {\n                    var r,\n                        i,\n                        a = e.tracks;\n\n                    if (a.audio && this.altAudio && delete a.audio, i = a.audio) {\n                      var n = this.levels[this.level].audioCodec,\n                          s = navigator.userAgent.toLowerCase();\n                      n && this.audioCodecSwap && (k.logger.log(\"swapping playlist audio codec\"), n = n.indexOf(\"mp4a.40.5\") !== -1 ? \"mp4a.40.2\" : \"mp4a.40.5\"), this.audioCodecSwitch && 1 !== i.metadata.channelCount && s.indexOf(\"firefox\") === -1 && (n = \"mp4a.40.5\"), s.indexOf(\"android\") !== -1 && \"audio/mpeg\" !== i.container && (n = \"mp4a.40.2\", k.logger.log(\"Android: force audio codec to \" + n)), i.levelCodec = n, i.id = e.id;\n                    }\n\n                    if (i = a.video, i && (i.levelCodec = this.levels[this.level].videoCodec, i.id = e.id), e.unique) {\n                      var o = {\n                        codec: \"\",\n                        levelCodec: \"\"\n                      };\n\n                      for (r in e.tracks) {\n                        i = a[r], o.container = i.container, o.codec && (o.codec += \",\", o.levelCodec += \",\"), i.codec && (o.codec += i.codec), i.levelCodec && (o.levelCodec += i.levelCodec);\n                      }\n\n                      a = {\n                        audiovideo: o\n                      };\n                    }\n\n                    this.hls.trigger(g.default.BUFFER_CODECS, a);\n\n                    for (r in a) {\n                      i = a[r], k.logger.log(\"main track:\" + r + \",container:\" + i.container + \",codecs[level/parsed]=[\" + i.levelCodec + \"/\" + i.codec + \"]\");\n                      var l = i.initSegment;\n                      l && (this.pendingAppending++, this.hls.trigger(g.default.BUFFER_APPENDING, {\n                        type: r,\n                        data: l,\n                        parent: \"main\",\n                        content: \"initSegment\"\n                      }));\n                    }\n\n                    this.tick();\n                  }\n                }\n              }, {\n                key: \"onFragParsingData\",\n                value: function value(e) {\n                  var t = this,\n                      r = this.fragCurrent;\n\n                  if (r && \"main\" === e.id && e.sn === r.sn && e.level === r.level && (\"audio\" !== e.type || !this.altAudio) && this.state === T.PARSING) {\n                    var i = this.levels[this.level],\n                        a = this.fragCurrent;\n                    k.logger.log(\"Parsed \" + e.type + \",PTS:[\" + e.startPTS.toFixed(3) + \",\" + e.endPTS.toFixed(3) + \"],DTS:[\" + e.startDTS.toFixed(3) + \"/\" + e.endDTS.toFixed(3) + \"],nb:\" + e.nb + \",dropped:\" + (e.dropped || 0));\n                    var n = E.default.updateFragPTSDTS(i.details, a.sn, e.startPTS, e.endPTS, e.startDTS, e.endDTS),\n                        s = this.hls;\n                    s.trigger(g.default.LEVEL_PTS_UPDATED, {\n                      details: i.details,\n                      level: this.level,\n                      drift: n,\n                      type: e.type,\n                      start: e.startPTS,\n                      end: e.endPTS\n                    }), \"video\" === e.type && (a.dropped = e.dropped), [e.data1, e.data2].forEach(function (r) {\n                      r && (t.pendingAppending++, s.trigger(g.default.BUFFER_APPENDING, {\n                        type: e.type,\n                        data: r,\n                        parent: \"main\",\n                        content: \"data\"\n                      }));\n                    }), this.bufferRange.push({\n                      type: e.type,\n                      start: e.startPTS,\n                      end: e.endPTS,\n                      frag: a\n                    }), this.tick();\n                  }\n                }\n              }, {\n                key: \"onFragParsed\",\n                value: function value(e) {\n                  var t = this.fragCurrent;\n                  t && \"main\" === e.id && e.sn === t.sn && e.level === t.level && this.state === T.PARSING && (this.stats.tparsed = performance.now(), this.state = T.PARSED, this._checkAppendedParsed());\n                }\n              }, {\n                key: \"onAudioTrackSwitch\",\n                value: function value(e) {\n                  var t = !!e.url;\n                  if (t) this.videoBuffer && this.mediaBuffer !== this.videoBuffer && (k.logger.log(\"switching on alternate audio, use video.buffered to schedule main fragment loading\"), this.mediaBuffer = this.videoBuffer);else if (this.mediaBuffer !== this.media) {\n                    k.logger.log(\"switching on main audio, use media.buffered to schedule main fragment loading\"), this.mediaBuffer = this.media;\n                    var r = this.fragCurrent;\n                    r.loader && (k.logger.log(\"switching to main audio track, cancel main fragment load\"), r.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = T.IDLE;\n                  }\n                  this.altAudio = t;\n                }\n              }, {\n                key: \"onBufferCreated\",\n                value: function value(e) {\n                  var t = e.tracks,\n                      r = void 0,\n                      i = void 0,\n                      a = !1;\n\n                  for (var n in t) {\n                    var s = t[n];\n                    \"main\" === s.id ? (i = n, r = s, \"video\" === n && (this.videoBuffer = t[n].buffer)) : a = !0;\n                  }\n\n                  a && r ? (k.logger.log(\"alternate track found, use \" + i + \".buffered to schedule main fragment loading\"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media;\n                }\n              }, {\n                key: \"onBufferAppended\",\n                value: function value(e) {\n                  if (\"main\" === e.parent) switch (this.state) {\n                    case T.PARSING:\n                    case T.PARSED:\n                      this.pendingAppending--, this._checkAppendedParsed();\n                  }\n                }\n              }, {\n                key: \"_checkAppendedParsed\",\n                value: function value() {\n                  if (this.state === T.PARSED && 0 === this.pendingAppending) {\n                    var e = this.fragCurrent,\n                        t = this.stats;\n\n                    if (e) {\n                      this.fragPrevious = e, t.tbuffered = performance.now(), this.fragLastKbps = Math.round(8 * t.total / (t.tbuffered - t.tfirst)), this.hls.trigger(g.default.FRAG_BUFFERED, {\n                        stats: t,\n                        frag: e,\n                        id: \"main\"\n                      });\n                      var r = this.mediaBuffer ? this.mediaBuffer : this.media;\n                      k.logger.log(\"main buffered : \" + R.default.toString(r.buffered)), this.state = T.IDLE;\n                    }\n\n                    this.tick();\n                  }\n                }\n              }, {\n                key: \"onError\",\n                value: function value(e) {\n                  var t = e.frag || this.fragCurrent;\n\n                  if (!t || \"main\" === t.type) {\n                    var r = this.media,\n                        i = r && f.default.isBuffered(r, r.currentTime) && f.default.isBuffered(r, r.currentTime + .5);\n\n                    switch (e.details) {\n                      case _.ErrorDetails.FRAG_LOAD_ERROR:\n                      case _.ErrorDetails.FRAG_LOAD_TIMEOUT:\n                      case _.ErrorDetails.KEY_LOAD_ERROR:\n                      case _.ErrorDetails.KEY_LOAD_TIMEOUT:\n                        if (!e.fatal) {\n                          var a = this.fragLoadError;\n                          a ? a++ : a = 1;\n                          var n = this.config;\n\n                          if (n.fragLoadingMaxRetry >= a || i || t.autoLevel && t.level) {\n                            this.fragLoadError = a, t.loadCounter = 0;\n                            var s = Math.min(Math.pow(2, a - 1) * n.fragLoadingRetryDelay, n.fragLoadingMaxRetryTimeout);\n                            k.logger.warn(\"mediaController: frag loading failed, retry in \" + s + \" ms\"), this.retryDate = performance.now() + s, this.state = T.FRAG_LOADING_WAITING_RETRY;\n                          } else k.logger.error(\"mediaController: \" + e.details + \" reaches max retry, redispatch as fatal ...\"), e.fatal = !0, this.hls.trigger(g.default.ERROR, e), this.state = T.ERROR;\n                        }\n\n                        break;\n\n                      case _.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n                        e.fatal || (i ? (this._reduceMaxBufferLength(t.duration), this.state = T.IDLE) : t.autoLevel && 0 !== t.level || (e.fatal = !0, this.hls.trigger(g.default.ERROR, e), this.state = T.ERROR));\n                        break;\n\n                      case _.ErrorDetails.LEVEL_LOAD_ERROR:\n                      case _.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n                        this.state !== T.ERROR && (e.fatal ? (this.state = T.ERROR, k.logger.warn(\"streamController: \" + e.details + \",switch to \" + this.state + \" state ...\")) : this.state === T.WAITING_LEVEL && (this.state = T.IDLE));\n                        break;\n\n                      case _.ErrorDetails.BUFFER_FULL_ERROR:\n                        this.state !== T.PARSING && this.state !== T.PARSED || (i ? (this._reduceMaxBufferLength(t.duration), this.state = T.IDLE) : (k.logger.warn(\"buffer full error also media.currentTime is not buffered, flush everything\"), this.fragCurrent = null, this.state = T.PAUSED, this.hls.trigger(g.default.BUFFER_FLUSHING, {\n                          startOffset: 0,\n                          endOffset: Number.POSITIVE_INFINITY\n                        })));\n                    }\n                  }\n                }\n              }, {\n                key: \"_reduceMaxBufferLength\",\n                value: function value(e) {\n                  var t = this.config;\n                  e > t.maxMaxBufferLength || (t.maxMaxBufferLength /= 2, k.logger.warn(\"reduce max buffer length to \" + t.maxMaxBufferLength + \"s and switch to IDLE state\"), this.fragLoadIdx += 2 * t.fragLoadingLoopThreshold);\n                }\n              }, {\n                key: \"_checkBuffer\",\n                value: function value() {\n                  var e = this.media;\n\n                  if (e && e.readyState) {\n                    var t = e.currentTime,\n                        r = e.buffered;\n                    if (this.loadedmetadata || !r.length || e.seeking) {\n                      if (this.immediateSwitch) this.immediateLevelSwitchEnd();else {\n                        var i = f.default.bufferInfo(e, t, 0),\n                            a = !(e.paused || e.ended || 0 === e.buffered.length),\n                            n = .5,\n                            s = t > e.playbackRate * this.lastCurrentTime,\n                            o = this.config;\n\n                        if (this.stalled && s && (this.stalled = !1, k.logger.log(\"playback not stuck anymore @\" + t)), a && n >= i.len && (s ? (n = 0, this.seekHoleNudgeDuration = 0) : this.stalled ? this.seekHoleNudgeDuration += o.seekHoleNudgeDuration : (this.seekHoleNudgeDuration = 0, k.logger.log(\"playback seems stuck @\" + t), this.hls.trigger(g.default.ERROR, {\n                          type: _.ErrorTypes.MEDIA_ERROR,\n                          details: _.ErrorDetails.BUFFER_STALLED_ERROR,\n                          fatal: !1\n                        }), this.stalled = !0), n >= i.len)) {\n                          var l = i.nextStart,\n                              u = l - t;\n\n                          if (l && o.maxSeekHole > u && u > 0) {\n                            k.logger.log(\"adjust currentTime from \" + e.currentTime + \" to next buffered @ \" + l + \" + nudge \" + this.seekHoleNudgeDuration);\n                            var d = l + this.seekHoleNudgeDuration - e.currentTime;\n                            e.currentTime = l + this.seekHoleNudgeDuration, this.hls.trigger(g.default.ERROR, {\n                              type: _.ErrorTypes.MEDIA_ERROR,\n                              details: _.ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n                              fatal: !1,\n                              hole: d\n                            });\n                          }\n                        }\n                      }\n                    } else {\n                      this.loadedmetadata = !0;\n                      var h = this.startPosition,\n                          c = f.default.isBuffered(e, h);\n                      t === h && c || (k.logger.log(\"target start position:\" + h), c || (h = r.start(0), k.logger.log(\"target start position not buffered, seek to buffered.start(0) \" + h)), k.logger.log(\"adjust currentTime from \" + t + \" to \" + h), e.currentTime = h);\n                    }\n                  }\n                }\n              }, {\n                key: \"onFragLoadEmergencyAborted\",\n                value: function value() {\n                  this.state = T.IDLE, this.loadedmetadata || (this.startFragRequested = !1), this.tick();\n                }\n              }, {\n                key: \"onBufferFlushed\",\n                value: function value() {\n                  var e = this.mediaBuffer ? this.mediaBuffer : this.media,\n                      t = this.bufferRange,\n                      r = [],\n                      i = void 0,\n                      a = void 0;\n\n                  for (a = 0; t.length > a; a++) {\n                    i = t[a], f.default.isBuffered(e, (i.start + i.end) / 2) && r.push(i);\n                  }\n\n                  this.bufferRange = r, this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold, this.state = T.IDLE, this.fragPrevious = null;\n                }\n              }, {\n                key: \"swapAudioCodec\",\n                value: function value() {\n                  this.audioCodecSwap = !this.audioCodecSwap;\n                }\n              }, {\n                key: \"computeLivePosition\",\n                value: function value(e, t) {\n                  var r = void 0 !== this.config.liveSyncDuration ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * t.targetduration;\n                  return e + Math.max(0, t.totalduration - r);\n                }\n              }, {\n                key: \"state\",\n                set: function set(e) {\n                  if (this.state !== e) {\n                    var t = this.state;\n                    this._state = e, k.logger.log(\"engine state transition from \" + t + \" to \" + e), this.hls.trigger(g.default.STREAM_STATE_TRANSITION, {\n                      previousState: t,\n                      nextState: e\n                    });\n                  }\n                },\n                get: function get() {\n                  return this._state;\n                }\n              }, {\n                key: \"currentLevel\",\n                get: function get() {\n                  var e = this.media;\n\n                  if (e) {\n                    var t = this.getBufferRange(e.currentTime);\n                    if (t) return t.frag.level;\n                  }\n\n                  return -1;\n                }\n              }, {\n                key: \"nextBufferRange\",\n                get: function get() {\n                  var e = this.media;\n                  return e ? this.followingBufferRange(this.getBufferRange(e.currentTime)) : null;\n                }\n              }, {\n                key: \"nextLevel\",\n                get: function get() {\n                  var e = this.nextBufferRange;\n                  return e ? e.frag.level : -1;\n                }\n              }, {\n                key: \"liveSyncPosition\",\n                get: function get() {\n                  return this._liveSyncPosition;\n                },\n                set: function set(e) {\n                  this._liveSyncPosition = e;\n                }\n              }]), t;\n            }(y.default);\n\n            r.default = A;\n          }, {\n            22: 22,\n            26: 26,\n            27: 27,\n            28: 28,\n            30: 30,\n            31: 31,\n            41: 41,\n            45: 45,\n            46: 46\n          }],\n          13: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(42),\n                c = i(h),\n                v = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.MEDIA_ATTACHING, u.default.MEDIA_DETACHING, u.default.FRAG_PARSING_USERDATA, u.default.MANIFEST_LOADING, u.default.FRAG_LOADED, u.default.LEVEL_SWITCH));\n\n                if (r.hls = e, r.config = e.config, r.enabled = !0, r.Cues = e.config.cueHandler, r.config.enableCEA708Captions) {\n                  var i = r,\n                      s = function s(e, t) {\n                    var r = null;\n\n                    try {\n                      r = new window.Event(\"addtrack\");\n                    } catch (e) {\n                      r = document.createEvent(\"Event\"), r.initEvent(\"addtrack\", !1, !1);\n                    }\n\n                    r.track = e, t.dispatchEvent(r);\n                  },\n                      o = {\n                    newCue: function newCue(e, t, r) {\n                      if (!i.textTrack1) {\n                        var a = i.getExistingTrack(\"1\");\n                        a ? (i.textTrack1 = a, i.clearCurrentCues(i.textTrack1), s(i.textTrack1, i.media)) : (i.textTrack1 = i.createTextTrack(\"captions\", \"English\", \"en\"), i.textTrack1.textTrack1 = !0);\n                      }\n\n                      i.Cues.newCue(i.textTrack1, e, t, r);\n                    }\n                  },\n                      l = {\n                    newCue: function newCue(e, t, r) {\n                      if (!i.textTrack2) {\n                        var a = i.getExistingTrack(\"2\");\n                        a ? (i.textTrack2 = a, i.clearCurrentCues(i.textTrack2), s(i.textTrack2, i.media)) : (i.textTrack2 = i.createTextTrack(\"captions\", \"Spanish\", \"es\"), i.textTrack2.textTrack2 = !0);\n                      }\n\n                      i.Cues.newCue(i.textTrack2, e, t, r);\n                    }\n                  };\n\n                  r.cea608Parser = new c.default(0, o, l);\n                }\n\n                return r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"clearCurrentCues\",\n                value: function value(e) {\n                  if (e && e.cues) for (; e.cues.length > 0;) {\n                    e.removeCue(e.cues[0]);\n                  }\n                }\n              }, {\n                key: \"getExistingTrack\",\n                value: function value(e) {\n                  var t = this.media;\n                  if (t) for (var r = 0; t.textTracks.length > r; r++) {\n                    var i = t.textTracks[r],\n                        a = \"textTrack\" + e;\n                    if (i[a] === !0) return i;\n                  }\n                  return null;\n                }\n              }, {\n                key: \"createTextTrack\",\n                value: function value(e, t, r) {\n                  if (this.media) return this.media.addTextTrack(e, t, r);\n                }\n              }, {\n                key: \"destroy\",\n                value: function value() {\n                  f.default.prototype.destroy.call(this);\n                }\n              }, {\n                key: \"onMediaAttaching\",\n                value: function value(e) {\n                  this.media = e.media;\n                }\n              }, {\n                key: \"onMediaDetaching\",\n                value: function value() {\n                  this.clearCurrentCues(this.textTrack1), this.clearCurrentCues(this.textTrack2);\n                }\n              }, {\n                key: \"onManifestLoading\",\n                value: function value() {\n                  this.lastPts = Number.NEGATIVE_INFINITY;\n                }\n              }, {\n                key: \"onLevelSwitch\",\n                value: function value() {\n                  this.enabled = \"NONE\" !== this.hls.currentLevel.closedCaptions;\n                }\n              }, {\n                key: \"onFragLoaded\",\n                value: function value(e) {\n                  if (\"main\" === e.frag.type) {\n                    var t = e.frag.start;\n                    t > this.lastPts || (this.clearCurrentCues(this.textTrack1), this.clearCurrentCues(this.textTrack2)), this.lastPts = t;\n                  }\n                }\n              }, {\n                key: \"onFragParsingUserdata\",\n                value: function value(e) {\n                  if (this.enabled && this.config.enableCEA708Captions) for (var t = 0; e.samples.length > t; t++) {\n                    var r = this.extractCea608Data(e.samples[t].bytes);\n                    this.cea608Parser.addData(e.samples[t].pts, r);\n                  }\n                }\n              }, {\n                key: \"extractCea608Data\",\n                value: function value(e) {\n                  for (var t, r, i, a, n, s = 31 & e[0], o = 2, l = [], u = 0; s > u; u++) {\n                    t = e[o++], r = 127 & e[o++], i = 127 & e[o++], a = 0 !== (4 & t), n = 3 & t, 0 === r && 0 === i || a && 0 === n && (l.push(r), l.push(i));\n                  }\n\n                  return l;\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = v;\n          }, {\n            27: 27,\n            28: 28,\n            42: 42\n          }],\n          14: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e(t, r) {\n                i(this, e), this.subtle = t, this.aesIV = r;\n              }\n\n              return a(e, [{\n                key: \"decrypt\",\n                value: function value(e, t) {\n                  return this.subtle.decrypt({\n                    name: \"AES-CBC\",\n                    iv: this.aesIV\n                  }, t, e);\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          15: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e() {\n                i(this, e), this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [], this.subMix[0] = new Uint32Array(256), this.subMix[1] = new Uint32Array(256), this.subMix[2] = new Uint32Array(256), this.subMix[3] = new Uint32Array(256), this.invSubMix = [], this.invSubMix[0] = new Uint32Array(256), this.invSubMix[1] = new Uint32Array(256), this.invSubMix[2] = new Uint32Array(256), this.invSubMix[3] = new Uint32Array(256), this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable();\n              }\n\n              return a(e, [{\n                key: \"uint8ArrayToUint32Array_\",\n                value: function value(e) {\n                  for (var t = new DataView(e), r = new Uint32Array(4), i = 0; r.length > i; i++) {\n                    r[i] = t.getUint32(4 * i);\n                  }\n\n                  return r;\n                }\n              }, {\n                key: \"initTable\",\n                value: function value() {\n                  var e = this.sBox,\n                      t = this.invSBox,\n                      r = this.subMix[0],\n                      i = this.subMix[1],\n                      a = this.subMix[2],\n                      n = this.subMix[3],\n                      s = this.invSubMix[0],\n                      o = this.invSubMix[1],\n                      l = this.invSubMix[2],\n                      u = this.invSubMix[3],\n                      d = new Uint32Array(256),\n                      f = 0,\n                      h = 0,\n                      c = 0;\n\n                  for (c = 0; 256 > c; c++) {\n                    d[c] = 128 > c ? c << 1 : c << 1 ^ 283;\n                  }\n\n                  for (c = 0; 256 > c; c++) {\n                    var v = h ^ h << 1 ^ h << 2 ^ h << 3 ^ h << 4;\n                    v = v >>> 8 ^ 255 & v ^ 99, e[f] = v, t[v] = f;\n                    var g = d[f],\n                        p = d[g],\n                        y = d[p],\n                        m = 257 * d[v] ^ 16843008 * v;\n                    r[f] = m << 24 | m >>> 8, i[f] = m << 16 | m >>> 16, a[f] = m << 8 | m >>> 24, n[f] = m, m = 16843009 * y ^ 65537 * p ^ 257 * g ^ 16843008 * f, s[v] = m << 24 | m >>> 8, o[v] = m << 16 | m >>> 16, l[v] = m << 8 | m >>> 24, u[v] = m, f ? (f = g ^ d[d[d[y ^ g]]], h ^= d[d[h]]) : f = h = 1;\n                  }\n                }\n              }, {\n                key: \"expandKey\",\n                value: function value(e) {\n                  for (var t = this.uint8ArrayToUint32Array_(e), r = !0, i = 0; t.length > i && r;) {\n                    r = t[i] === this.key[i], i++;\n                  }\n\n                  if (!r) {\n                    this.key = t;\n                    var a = this.keySize = t.length;\n                    if (4 !== a && 6 !== a && 8 !== a) throw Error(\"Invalid aes key size=\" + a);\n                    var n = this.ksRows = 4 * (a + 6 + 1),\n                        s = void 0,\n                        o = void 0,\n                        l = this.keySchedule = new Uint32Array(this.ksRows),\n                        u = this.invKeySchedule = new Uint32Array(this.ksRows),\n                        d = this.sBox,\n                        f = this.rcon,\n                        h = this.invSubMix[0],\n                        c = this.invSubMix[1],\n                        v = this.invSubMix[2],\n                        g = this.invSubMix[3],\n                        p = void 0,\n                        y = void 0;\n\n                    for (s = 0; n > s; s++) {\n                      a > s ? p = l[s] = t[s] : (y = p, s % a === 0 ? (y = y << 8 | y >>> 24, y = d[y >>> 24] << 24 | d[y >>> 16 & 255] << 16 | d[y >>> 8 & 255] << 8 | d[255 & y], y ^= f[s / a | 0] << 24) : a > 6 && s % a === 4 && (y = d[y >>> 24] << 24 | d[y >>> 16 & 255] << 16 | d[y >>> 8 & 255] << 8 | d[255 & y]), l[s] = p = (l[s - a] ^ y) >>> 0);\n                    }\n\n                    for (o = 0; n > o; o++) {\n                      s = n - o, y = 3 & o ? l[s] : l[s - 4], u[o] = 4 > o || 4 >= s ? y : h[d[y >>> 24]] ^ c[d[y >>> 16 & 255]] ^ v[d[y >>> 8 & 255]] ^ g[d[255 & y]], u[o] = u[o] >>> 0;\n                    }\n                  }\n                }\n              }, {\n                key: \"networkToHostOrderSwap\",\n                value: function value(e) {\n                  return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24;\n                }\n              }, {\n                key: \"decrypt\",\n                value: function value(e, t, r) {\n                  for (var i, a, n = this.keySize + 6, s = this.invKeySchedule, o = this.invSBox, l = this.invSubMix[0], u = this.invSubMix[1], d = this.invSubMix[2], f = this.invSubMix[3], h = this.uint8ArrayToUint32Array_(r), c = h[0], v = h[1], g = h[2], p = h[3], y = new Int32Array(e), m = new Int32Array(y.length), E = void 0, b = void 0, R = void 0, _ = void 0, k = void 0, T = void 0, A = void 0, S = void 0, L = void 0, D = void 0, O = void 0, w = void 0; y.length > t;) {\n                    for (L = this.networkToHostOrderSwap(y[t]), D = this.networkToHostOrderSwap(y[t + 1]), O = this.networkToHostOrderSwap(y[t + 2]), w = this.networkToHostOrderSwap(y[t + 3]), k = L ^ s[0], T = w ^ s[1], A = O ^ s[2], S = D ^ s[3], i = 4, a = 1; n > a; a++) {\n                      E = l[k >>> 24] ^ u[T >> 16 & 255] ^ d[A >> 8 & 255] ^ f[255 & S] ^ s[i], b = l[T >>> 24] ^ u[A >> 16 & 255] ^ d[S >> 8 & 255] ^ f[255 & k] ^ s[i + 1], R = l[A >>> 24] ^ u[S >> 16 & 255] ^ d[k >> 8 & 255] ^ f[255 & T] ^ s[i + 2], _ = l[S >>> 24] ^ u[k >> 16 & 255] ^ d[T >> 8 & 255] ^ f[255 & A] ^ s[i + 3], k = E, T = b, A = R, S = _, i += 4;\n                    }\n\n                    E = o[k >>> 24] << 24 ^ o[T >> 16 & 255] << 16 ^ o[A >> 8 & 255] << 8 ^ o[255 & S] ^ s[i], b = o[T >>> 24] << 24 ^ o[A >> 16 & 255] << 16 ^ o[S >> 8 & 255] << 8 ^ o[255 & k] ^ s[i + 1], R = o[A >>> 24] << 24 ^ o[S >> 16 & 255] << 16 ^ o[k >> 8 & 255] << 8 ^ o[255 & T] ^ s[i + 2], _ = o[S >>> 24] << 24 ^ o[k >> 16 & 255] << 16 ^ o[T >> 8 & 255] << 8 ^ o[255 & A] ^ s[i + 3], i += 3, m[t] = this.networkToHostOrderSwap(E ^ c), m[t + 1] = this.networkToHostOrderSwap(_ ^ v), m[t + 2] = this.networkToHostOrderSwap(R ^ g), m[t + 3] = this.networkToHostOrderSwap(b ^ p), c = L, v = D, g = O, p = w, t += 4;\n                  }\n\n                  return m.buffer;\n                }\n              }, {\n                key: \"destroy\",\n                value: function value() {\n                  this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0;\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          16: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(14),\n                o = i(s),\n                l = e(17),\n                u = i(l),\n                d = e(15),\n                f = i(d),\n                h = e(26),\n                c = e(45),\n                v = function () {\n              function e(t) {\n                a(this, e), this.hls = t;\n\n                try {\n                  var r = window ? window.crypto : crypto;\n                  this.subtle = r.subtle || r.webkitSubtle;\n                } catch (e) {}\n\n                this.disableWebCrypto = !this.supportsWebCrypto();\n              }\n\n              return n(e, [{\n                key: \"supportsWebCrypto\",\n                value: function value() {\n                  return this.subtle && \"https:\" === window.location.protocol;\n                }\n              }, {\n                key: \"decrypt\",\n                value: function value(e, t, r, i) {\n                  var a = this;\n                  this.disableWebCrypto && this.hls.config.enableSoftwareAES ? (c.logger.log(\"decrypting by JavaScript Implementation\"), this.decryptor || (this.decryptor = new f.default()), this.decryptor.expandKey(t), i(this.decryptor.decrypt(e, 0, r))) : !function () {\n                    c.logger.log(\"decrypting by WebCrypto API\");\n                    var n = a.subtle;\n                    a.key !== t && (a.key = t, a.fastAesKey = new u.default(n, t)), a.fastAesKey.expandKey().then(function (t) {\n                      var a = new o.default(n, r);\n                      a.decrypt(e, t).then(function (e) {\n                        i(e);\n                      });\n                    }).catch(function (n) {\n                      a.onWebCryptoError(n, e, t, r, i);\n                    });\n                  }();\n                }\n              }, {\n                key: \"onWebCryptoError\",\n                value: function value(e, t, r, i, a) {\n                  var n = this.hls;\n                  n.config.enableSoftwareAES ? (c.logger.log(\"disabling to use WebCrypto API\"), this.disableWebCrypto = !0, this.decrypt(t, r, i, a)) : (c.logger.error(\"decrypting error : \" + e.message), n.trigger(Event.ERROR, {\n                    type: h.ErrorTypes.MEDIA_ERROR,\n                    details: h.ErrorDetails.FRAG_DECRYPT_ERROR,\n                    fatal: !0,\n                    reason: e.message\n                  }));\n                }\n              }, {\n                key: \"destroy\",\n                value: function value() {\n                  var e = this.decryptor;\n                  e && (e.destroy(), this.decryptor = void 0);\n                }\n              }]), e;\n            }();\n\n            r.default = v;\n          }, {\n            14: 14,\n            15: 15,\n            17: 17,\n            26: 26,\n            45: 45\n          }],\n          17: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e(t, r) {\n                i(this, e), this.subtle = t, this.key = r;\n              }\n\n              return a(e, [{\n                key: \"expandKey\",\n                value: function value() {\n                  return this.subtle.importKey(\"raw\", this.key, {\n                    name: \"AES-CBC\"\n                  }, !1, [\"encrypt\", \"decrypt\"]);\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          18: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(19),\n                o = i(s),\n                l = e(45),\n                u = e(24),\n                d = i(u),\n                f = function () {\n              function e(t, r, i, n, s) {\n                a(this, e), this.observer = t, this.id = r, this.remuxerClass = i, this.config = n, this.remuxer = new this.remuxerClass(t, r, n, s), this.insertDiscontinuity();\n              }\n\n              return n(e, [{\n                key: \"insertDiscontinuity\",\n                value: function value() {\n                  this._aacTrack = {\n                    container: \"audio/adts\",\n                    type: \"audio\",\n                    id: -1,\n                    sequenceNumber: 0,\n                    isAAC: !0,\n                    samples: [],\n                    len: 0\n                  };\n                }\n              }, {\n                key: \"push\",\n                value: function value(e, t, r, i, a, n, s, u, f) {\n                  var h,\n                      c,\n                      v,\n                      g,\n                      p,\n                      y,\n                      m,\n                      E,\n                      b,\n                      R,\n                      _ = new d.default(e),\n                      k = 90 * _.timeStamp,\n                      T = !1;\n\n                  for (a !== this.lastCC ? (l.logger.log(this.id + \" discontinuity detected\"), this.lastCC = a, this.insertDiscontinuity(), this.remuxer.switchLevel(), this.remuxer.insertDiscontinuity()) : n !== this.lastLevel ? (l.logger.log(\"audio track switch detected\"), this.lastLevel = n, this.remuxer.switchLevel(), this.insertDiscontinuity()) : s === this.lastSN + 1 && (T = !0), h = this._aacTrack, this.lastSN = s, this.lastLevel = n, y = _.length, b = e.length; b - 1 > y && (255 !== e[y] || 240 !== (240 & e[y + 1])); y++) {\n                    ;\n                  }\n\n                  for (h.audiosamplerate || (c = o.default.getAudioConfig(this.observer, e, y, t), h.config = c.config, h.audiosamplerate = c.samplerate, h.channelCount = c.channelCount, h.codec = c.codec, h.duration = u, l.logger.log(\"parsed codec:\" + h.codec + \",rate:\" + c.samplerate + \",nb channel:\" + c.channelCount)), p = 0, g = 9216e4 / h.audiosamplerate; b > y + 5 && (m = 1 & e[y + 1] ? 7 : 9, v = (3 & e[y + 3]) << 11 | e[y + 4] << 3 | (224 & e[y + 5]) >>> 5, v -= m, v > 0 && b >= y + m + v);) {\n                    for (E = k + p * g, R = {\n                      unit: e.subarray(y + m, y + m + v),\n                      pts: E,\n                      dts: E\n                    }, h.samples.push(R), h.len += v, y += v + m, p++; b - 1 > y && (255 !== e[y] || 240 !== (240 & e[y + 1])); y++) {\n                      ;\n                    }\n                  }\n\n                  this.remuxer.remux(n, s, this._aacTrack, {\n                    samples: []\n                  }, {\n                    samples: [{\n                      pts: k,\n                      dts: k,\n                      unit: _.payload\n                    }]\n                  }, {\n                    samples: []\n                  }, i, T, f);\n                }\n              }, {\n                key: \"destroy\",\n                value: function value() {}\n              }], [{\n                key: \"probe\",\n                value: function value(e) {\n                  var t,\n                      r,\n                      i = new d.default(e);\n                  if (i.hasTimeStamp) for (t = i.length, r = e.length; r - 1 > t; t++) {\n                    if (255 === e[t] && 240 === (240 & e[t + 1])) return !0;\n                  }\n                  return !1;\n                }\n              }]), e;\n            }();\n\n            r.default = f;\n          }, {\n            19: 19,\n            24: 24,\n            45: 45\n          }],\n          19: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = e(45),\n                s = e(26),\n                o = function () {\n              function e() {\n                i(this, e);\n              }\n\n              return a(e, null, [{\n                key: \"getAudioConfig\",\n                value: function value(e, t, r, i) {\n                  var a,\n                      o,\n                      l,\n                      u,\n                      d,\n                      f = navigator.userAgent.toLowerCase(),\n                      h = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];\n                  return a = ((192 & t[r + 2]) >>> 6) + 1, o = (60 & t[r + 2]) >>> 2, o > h.length - 1 ? void e.trigger(Event.ERROR, {\n                    type: s.ErrorTypes.MEDIA_ERROR,\n                    details: s.ErrorDetails.FRAG_PARSING_ERROR,\n                    fatal: !0,\n                    reason: \"invalid ADTS sampling index:\" + o\n                  }) : (u = (1 & t[r + 2]) << 2, u |= (192 & t[r + 3]) >>> 6, n.logger.log(\"manifest codec:\" + i + \",ADTS data:type:\" + a + \",sampleingIndex:\" + o + \"[\" + h[o] + \"Hz],channelConfig:\" + u), /firefox|OPR/i.test(f) ? 6 > o ? (a = 2, d = Array(2), l = o) : (a = 5, d = Array(4), l = o - 3) : f.indexOf(\"android\") !== -1 ? (a = 2, d = Array(2), l = o) : (a = 5, d = Array(4), i && (i.indexOf(\"mp4a.40.29\") !== -1 || i.indexOf(\"mp4a.40.5\") !== -1) || !i && o >= 6 ? l = o - 3 : ((i && i.indexOf(\"mp4a.40.2\") !== -1 && o >= 6 && 1 === u || !i && 1 === u) && (a = 2, d = Array(2)), l = o)), d[0] = a << 3, d[0] |= (14 & o) >> 1, d[1] |= (1 & o) << 7, d[1] |= u << 3, 5 === a && (d[1] |= (14 & l) >> 1, d[2] = (1 & l) << 7, d[2] |= 8, d[3] = 0), {\n                    config: d,\n                    samplerate: h[o],\n                    channelCount: u,\n                    codec: \"mp4a.40.\" + a\n                  });\n                }\n              }]), e;\n            }();\n\n            r.default = o;\n          }, {\n            26: 26,\n            45: 45\n          }],\n          20: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(28),\n                o = i(s),\n                l = e(26),\n                u = e(18),\n                d = i(u),\n                f = e(25),\n                h = i(f),\n                c = e(38),\n                v = i(c),\n                g = e(39),\n                p = i(g),\n                y = function () {\n              function e(t, r, i) {\n                var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;\n                a(this, e), this.hls = t, this.id = r, this.config = this.hls.config || n, this.typeSupported = i;\n              }\n\n              return n(e, [{\n                key: \"destroy\",\n                value: function value() {\n                  var e = this.demuxer;\n                  e && e.destroy();\n                }\n              }, {\n                key: \"push\",\n                value: function value(e, t, r, i, a, n, s, u, f) {\n                  var c = this.demuxer;\n\n                  if (!c) {\n                    var g = this.hls,\n                        y = this.id,\n                        m = this.config,\n                        E = this.typeSupported;\n                    if (h.default.probe(e)) c = this.typeSupported.mp2t === !0 ? new h.default(g, y, p.default, m, E) : new h.default(g, y, v.default, m, E);else {\n                      if (!d.default.probe(e)) return void g.trigger(o.default.ERROR, {\n                        type: l.ErrorTypes.MEDIA_ERROR,\n                        id: y,\n                        details: l.ErrorDetails.FRAG_PARSING_ERROR,\n                        fatal: !0,\n                        reason: \"no demux matching with content found\"\n                      });\n                      c = new d.default(g, y, v.default, m, E);\n                    }\n                    this.demuxer = c;\n                  }\n\n                  c.push(e, t, r, i, a, n, s, u, f);\n                }\n              }]), e;\n            }();\n\n            r.default = y;\n          }, {\n            18: 18,\n            25: 25,\n            26: 26,\n            28: 28,\n            38: 38,\n            39: 39\n          }],\n          21: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = e(20),\n                n = i(a),\n                s = e(28),\n                o = i(s),\n                l = e(45),\n                u = e(1),\n                d = i(u),\n                f = function f(e) {\n              var t = new d.default();\n              t.trigger = function (e) {\n                for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), a = 1; r > a; a++) {\n                  i[a - 1] = arguments[a];\n                }\n\n                t.emit.apply(t, [e, e].concat(i));\n              }, t.off = function (e) {\n                for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), a = 1; r > a; a++) {\n                  i[a - 1] = arguments[a];\n                }\n\n                t.removeListener.apply(t, [e].concat(i));\n              };\n\n              var r = function r(t, _r) {\n                e.postMessage({\n                  event: t,\n                  data: _r\n                });\n              };\n\n              e.addEventListener(\"message\", function (i) {\n                var a = i.data;\n\n                switch (a.cmd) {\n                  case \"init\":\n                    var s = JSON.parse(a.config);\n                    e.demuxer = new n.default(t, a.id, a.typeSupported, s);\n\n                    try {\n                      (0, l.enableLogs)(s.debug === !0);\n                    } catch (e) {\n                      console.warn(\"demuxerWorker: unable to enable logs\");\n                    }\n\n                    r(\"init\", null);\n                    break;\n\n                  case \"demux\":\n                    e.demuxer.push(new Uint8Array(a.data), a.audioCodec, a.videoCodec, a.timeOffset, a.cc, a.level, a.sn, a.duration, a.accurateTimeOffset);\n                }\n              }), t.on(o.default.FRAG_PARSING_INIT_SEGMENT, r), t.on(o.default.FRAG_PARSED, r), t.on(o.default.ERROR, r), t.on(o.default.FRAG_PARSING_METADATA, r), t.on(o.default.FRAG_PARSING_USERDATA, r), t.on(o.default.FRAG_PARSING_DATA, function (t, r) {\n                var i = r.data1.buffer,\n                    a = r.data2.buffer;\n                delete r.data1, delete r.data2, e.postMessage({\n                  event: t,\n                  data: r,\n                  data1: i,\n                  data2: a\n                }, [i, a]);\n              });\n            };\n\n            r.default = f;\n          }, {\n            1: 1,\n            20: 20,\n            28: 28,\n            45: 45\n          }],\n          22: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(28),\n                o = i(s),\n                l = e(20),\n                u = i(l),\n                d = e(21),\n                f = i(d),\n                h = e(45),\n                c = e(16),\n                v = i(c),\n                g = e(26),\n                p = function () {\n              function t(r, i) {\n                a(this, t), this.hls = r, this.id = i;\n                var n = {\n                  mp4: MediaSource.isTypeSupported(\"video/mp4\"),\n                  mp2t: r.config.enableMP2TPassThrough && MediaSource.isTypeSupported(\"video/mp2t\"),\n                  mpeg: MediaSource.isTypeSupported(\"audio/mpeg\"),\n                  mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n                };\n\n                if (r.config.enableWorker && \"undefined\" != typeof Worker) {\n                  h.logger.log(\"demuxing in webworker\");\n                  var s = void 0;\n\n                  try {\n                    var l = e(3);\n                    s = this.w = l(f.default), this.onwmsg = this.onWorkerMessage.bind(this), s.addEventListener(\"message\", this.onwmsg), s.onerror = function (e) {\n                      r.trigger(o.default.ERROR, {\n                        type: g.ErrorTypes.OTHER_ERROR,\n                        details: g.ErrorDetails.INTERNAL_EXCEPTION,\n                        fatal: !0,\n                        event: \"demuxerWorker\",\n                        err: {\n                          message: e.message + \" (\" + e.filename + \":\" + e.lineno + \")\"\n                        }\n                      });\n                    }, s.postMessage({\n                      cmd: \"init\",\n                      typeSupported: n,\n                      id: i,\n                      config: JSON.stringify(r.config)\n                    });\n                  } catch (e) {\n                    h.logger.error(\"error while initializing DemuxerWorker, fallback on DemuxerInline\"), s && URL.revokeObjectURL(s.objectURL), this.demuxer = new u.default(r, i, n);\n                  }\n                } else this.demuxer = new u.default(r, i, n);\n\n                this.demuxInitialized = !0;\n              }\n\n              return n(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  var e = this.w;\n                  if (e) e.removeEventListener(\"message\", this.onwmsg), e.terminate(), this.w = null;else {\n                    var t = this.demuxer;\n                    t && (t.destroy(), this.demuxer = null);\n                  }\n                  var r = this.decrypter;\n                  r && (r.destroy(), this.decrypter = null);\n                }\n              }, {\n                key: \"pushDecrypted\",\n                value: function value(e, t, r, i, a, n, s, o, l) {\n                  var u = this.w;\n                  if (u) u.postMessage({\n                    cmd: \"demux\",\n                    data: e,\n                    audioCodec: t,\n                    videoCodec: r,\n                    timeOffset: i,\n                    cc: a,\n                    level: n,\n                    sn: s,\n                    duration: o,\n                    accurateTimeOffset: l\n                  }, [e]);else {\n                    var d = this.demuxer;\n                    d && d.push(new Uint8Array(e), t, r, i, a, n, s, o, l);\n                  }\n                }\n              }, {\n                key: \"push\",\n                value: function value(e, t, r, i, a, n, s, l, u, d) {\n                  if (e.byteLength > 0 && null != u && null != u.key && \"AES-128\" === u.method) {\n                    null == this.decrypter && (this.decrypter = new v.default(this.hls));\n                    var f = this,\n                        h = performance.now();\n                    this.decrypter.decrypt(e, u.key.buffer, u.iv.buffer, function (e) {\n                      f.hls.trigger(o.default.FRAG_DECRYPTED, {\n                        level: n,\n                        sn: s,\n                        stats: {\n                          tstart: h,\n                          tdecrypt: performance.now()\n                        }\n                      }), f.pushDecrypted(e, t, r, i, a, n, s, l, d);\n                    });\n                  } else this.pushDecrypted(e, t, r, i, a, n, s, l, d);\n                }\n              }, {\n                key: \"onWorkerMessage\",\n                value: function value(e) {\n                  var t = e.data,\n                      r = this.hls;\n\n                  switch (t.event) {\n                    case \"init\":\n                      URL.revokeObjectURL(this.w.objectURL);\n                      break;\n\n                    case o.default.FRAG_PARSING_DATA:\n                      t.data.data1 = new Uint8Array(t.data1), t.data.data2 = new Uint8Array(t.data2);\n\n                    default:\n                      r.trigger(t.event, t.data);\n                  }\n                }\n              }]), t;\n            }();\n\n            r.default = p;\n          }, {\n            16: 16,\n            20: 20,\n            21: 21,\n            26: 26,\n            28: 28,\n            3: 3,\n            45: 45\n          }],\n          23: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = e(45),\n                s = function () {\n              function e(t) {\n                i(this, e), this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0;\n              }\n\n              return a(e, [{\n                key: \"loadWord\",\n                value: function value() {\n                  var e = this.data,\n                      t = this.bytesAvailable,\n                      r = e.byteLength - t,\n                      i = new Uint8Array(4),\n                      a = Math.min(4, t);\n                  if (0 === a) throw Error(\"no bytes available\");\n                  i.set(e.subarray(r, r + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * a, this.bytesAvailable -= a;\n                }\n              }, {\n                key: \"skipBits\",\n                value: function value(e) {\n                  var t;\n                  this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t >> 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);\n                }\n              }, {\n                key: \"readBits\",\n                value: function value(e) {\n                  var t = Math.min(this.bitsAvailable, e),\n                      r = this.word >>> 32 - t;\n                  return e > 32 && n.logger.error(\"Cannot read more than 32 bits at a time\"), this.bitsAvailable -= t, this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(), t = e - t, t > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r;\n                }\n              }, {\n                key: \"skipLZ\",\n                value: function value() {\n                  var e;\n\n                  for (e = 0; this.bitsAvailable > e; ++e) {\n                    if (0 !== (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;\n                  }\n\n                  return this.loadWord(), e + this.skipLZ();\n                }\n              }, {\n                key: \"skipUEG\",\n                value: function value() {\n                  this.skipBits(1 + this.skipLZ());\n                }\n              }, {\n                key: \"skipEG\",\n                value: function value() {\n                  this.skipBits(1 + this.skipLZ());\n                }\n              }, {\n                key: \"readUEG\",\n                value: function value() {\n                  var e = this.skipLZ();\n                  return this.readBits(e + 1) - 1;\n                }\n              }, {\n                key: \"readEG\",\n                value: function value() {\n                  var e = this.readUEG();\n                  return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);\n                }\n              }, {\n                key: \"readBoolean\",\n                value: function value() {\n                  return 1 === this.readBits(1);\n                }\n              }, {\n                key: \"readUByte\",\n                value: function value() {\n                  return this.readBits(8);\n                }\n              }, {\n                key: \"readUShort\",\n                value: function value() {\n                  return this.readBits(16);\n                }\n              }, {\n                key: \"readUInt\",\n                value: function value() {\n                  return this.readBits(32);\n                }\n              }, {\n                key: \"skipScalingList\",\n                value: function value(e) {\n                  var t,\n                      r,\n                      i = 8,\n                      a = 8;\n\n                  for (t = 0; e > t; t++) {\n                    0 !== a && (r = this.readEG(), a = (i + r + 256) % 256), i = 0 === a ? i : a;\n                  }\n                }\n              }, {\n                key: \"readSPS\",\n                value: function value() {\n                  var e,\n                      t,\n                      r,\n                      i,\n                      a,\n                      n,\n                      s,\n                      o,\n                      l,\n                      u = 0,\n                      d = 0,\n                      f = 0,\n                      h = 0,\n                      c = 1,\n                      v = this.readUByte.bind(this),\n                      g = this.readBits.bind(this),\n                      p = this.readUEG.bind(this),\n                      y = this.readBoolean.bind(this),\n                      m = this.skipBits.bind(this),\n                      E = this.skipEG.bind(this),\n                      b = this.skipUEG.bind(this),\n                      R = this.skipScalingList.bind(this);\n\n                  if (v(), e = v(), t = g(5), m(3), r = v(), b(), 100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e) {\n                    var _ = p();\n\n                    if (3 === _ && m(1), b(), b(), m(1), y()) for (o = 3 !== _ ? 8 : 12, l = 0; o > l; l++) {\n                      y() && R(6 > l ? 16 : 64);\n                    }\n                  }\n\n                  b();\n                  var k = p();\n                  if (0 === k) p();else if (1 === k) for (m(1), E(), E(), i = p(), l = 0; i > l; l++) {\n                    E();\n                  }\n\n                  if (b(), m(1), a = p(), n = p(), s = g(1), 0 === s && m(1), m(1), y() && (u = p(), d = p(), f = p(), h = p()), y() && y()) {\n                    var T = void 0,\n                        A = v();\n\n                    switch (A) {\n                      case 1:\n                        T = [1, 1];\n                        break;\n\n                      case 2:\n                        T = [12, 11];\n                        break;\n\n                      case 3:\n                        T = [10, 11];\n                        break;\n\n                      case 4:\n                        T = [16, 11];\n                        break;\n\n                      case 5:\n                        T = [40, 33];\n                        break;\n\n                      case 6:\n                        T = [24, 11];\n                        break;\n\n                      case 7:\n                        T = [20, 11];\n                        break;\n\n                      case 8:\n                        T = [32, 11];\n                        break;\n\n                      case 9:\n                        T = [80, 33];\n                        break;\n\n                      case 10:\n                        T = [18, 11];\n                        break;\n\n                      case 11:\n                        T = [15, 11];\n                        break;\n\n                      case 12:\n                        T = [64, 33];\n                        break;\n\n                      case 13:\n                        T = [160, 99];\n                        break;\n\n                      case 14:\n                        T = [4, 3];\n                        break;\n\n                      case 15:\n                        T = [3, 2];\n                        break;\n\n                      case 16:\n                        T = [2, 1];\n                        break;\n\n                      case 255:\n                        T = [v() << 8 | v(), v() << 8 | v()];\n                    }\n\n                    T && (c = T[0] / T[1]);\n                  }\n\n                  return {\n                    width: Math.ceil((16 * (a + 1) - 2 * u - 2 * d) * c),\n                    height: (2 - s) * (n + 1) * 16 - (s ? 2 : 4) * (f + h)\n                  };\n                }\n              }, {\n                key: \"readSliceType\",\n                value: function value() {\n                  return this.readUByte(), this.readUEG(), this.readUEG();\n                }\n              }]), e;\n            }();\n\n            r.default = s;\n          }, {\n            45: 45\n          }],\n          24: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = e(45),\n                s = function () {\n              function e(t) {\n                i(this, e), this._hasTimeStamp = !1;\n\n                for (var r, a, s, o, l, u, d, f, h = 0;;) {\n                  if (d = this.readUTF(t, h, 3), h += 3, \"ID3\" === d) h += 3, r = 127 & t[h++], a = 127 & t[h++], s = 127 & t[h++], o = 127 & t[h++], l = (r << 21) + (a << 14) + (s << 7) + o, u = h + l, this._parseID3Frames(t, h, u), h = u;else {\n                    if (\"3DI\" !== d) return h -= 3, f = h, void (f && (this.hasTimeStamp || n.logger.warn(\"ID3 tag found, but no timestamp\"), this._length = f, this._payload = t.subarray(0, f)));\n                    h += 7, n.logger.log(\"3DI footer found, end: \" + h);\n                  }\n                }\n              }\n\n              return a(e, [{\n                key: \"readUTF\",\n                value: function value(e, t, r) {\n                  var i = \"\",\n                      a = t,\n                      n = t + r;\n\n                  do {\n                    i += String.fromCharCode(e[a++]);\n                  } while (n > a);\n\n                  return i;\n                }\n              }, {\n                key: \"_parseID3Frames\",\n                value: function value(e, t, r) {\n                  for (var i, a, s, o, l; r >= t + 8;) {\n                    switch (i = this.readUTF(e, t, 4), t += 4, a = e[t++] << 24 + e[t++] << 16 + e[t++] << 8 + e[t++], o = e[t++] << 8 + e[t++], s = t, i) {\n                      case \"PRIV\":\n                        if (\"com.apple.streaming.transportStreamTimestamp\" === this.readUTF(e, t, 44)) {\n                          t += 44, t += 4;\n                          var u = 1 & e[t++];\n                          this._hasTimeStamp = !0, l = ((e[t++] << 23) + (e[t++] << 15) + (e[t++] << 7) + e[t++]) / 45, u && (l += 47721858.84), l = Math.round(l), n.logger.trace(\"ID3 timestamp found: \" + l), this._timeStamp = l;\n                        }\n\n                    }\n                  }\n                }\n              }, {\n                key: \"hasTimeStamp\",\n                get: function get() {\n                  return this._hasTimeStamp;\n                }\n              }, {\n                key: \"timeStamp\",\n                get: function get() {\n                  return this._timeStamp;\n                }\n              }, {\n                key: \"length\",\n                get: function get() {\n                  return this._length;\n                }\n              }, {\n                key: \"payload\",\n                get: function get() {\n                  return this._payload;\n                }\n              }]), e;\n            }();\n\n            r.default = s;\n          }, {\n            45: 45\n          }],\n          25: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(19),\n                o = i(s),\n                l = e(28),\n                u = i(l),\n                d = e(23),\n                f = i(d),\n                h = e(45),\n                c = e(26),\n                v = function () {\n              function e(t, r, i, n, s) {\n                a(this, e), this.observer = t, this.id = r, this.remuxerClass = i, this.config = n, this.typeSupported = s, this.lastCC = 0, this.remuxer = new this.remuxerClass(t, r, n, s);\n              }\n\n              return n(e, [{\n                key: \"switchLevel\",\n                value: function value() {\n                  this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = {\n                    container: \"video/mp2t\",\n                    type: \"video\",\n                    id: -1,\n                    sequenceNumber: 0,\n                    samples: [],\n                    len: 0,\n                    dropped: 0\n                  }, this._audioTrack = {\n                    container: \"video/mp2t\",\n                    type: \"audio\",\n                    id: -1,\n                    sequenceNumber: 0,\n                    samples: [],\n                    len: 0,\n                    isAAC: !0\n                  }, this._id3Track = {\n                    type: \"id3\",\n                    id: -1,\n                    sequenceNumber: 0,\n                    samples: [],\n                    len: 0\n                  }, this._txtTrack = {\n                    type: \"text\",\n                    id: -1,\n                    sequenceNumber: 0,\n                    samples: [],\n                    len: 0\n                  }, this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.remuxer.switchLevel();\n                }\n              }, {\n                key: \"insertDiscontinuity\",\n                value: function value() {\n                  this.switchLevel(), this.remuxer.insertDiscontinuity();\n                }\n              }, {\n                key: \"push\",\n                value: function value(e, t, r, i, a, n, s, o, l) {\n                  var d,\n                      f,\n                      v,\n                      g,\n                      p,\n                      y,\n                      m = e.length,\n                      E = this.remuxer.passthrough,\n                      b = !1;\n                  this.audioCodec = t, this.videoCodec = r, this._duration = o, this.contiguous = !1, this.accurateTimeOffset = l, a !== this.lastCC && (h.logger.log(\"discontinuity detected\"), this.insertDiscontinuity(), this.lastCC = a), n !== this.lastLevel ? (h.logger.log(\"level switch detected\"), this.switchLevel(), this.lastLevel = n) : s === this.lastSN + 1 && (this.contiguous = !0), this.lastSN = s;\n\n                  var R = this.pmtParsed,\n                      _ = this._avcTrack,\n                      k = this._audioTrack,\n                      T = this._id3Track,\n                      A = _.id,\n                      S = k.id,\n                      L = T.id,\n                      D = this._pmtId,\n                      O = _.pesData,\n                      w = k.pesData,\n                      P = T.pesData,\n                      C = this._parsePAT,\n                      I = this._parsePMT,\n                      M = this._parsePES,\n                      x = this._parseAVCPES.bind(this),\n                      F = this._parseAACPES.bind(this),\n                      N = this._parseMPEGPES.bind(this),\n                      U = this._parseID3PES.bind(this);\n\n                  for (m -= m % 188, d = 0; m > d; d += 188) {\n                    if (71 === e[d]) {\n                      if (f = !!(64 & e[d + 1]), v = ((31 & e[d + 1]) << 8) + e[d + 2], g = (48 & e[d + 3]) >> 4, g > 1) {\n                        if (p = d + 5 + e[d + 4], p === d + 188) continue;\n                      } else p = d + 4;\n\n                      switch (v) {\n                        case A:\n                          if (f) {\n                            if (O && (y = M(O)) && (x(y, !1), E && _.codec && (S === -1 || k.codec))) return void this.remux(n, s, e, i);\n                            O = {\n                              data: [],\n                              size: 0\n                            };\n                          }\n\n                          O && (O.data.push(e.subarray(p, d + 188)), O.size += d + 188 - p);\n                          break;\n\n                        case S:\n                          if (f) {\n                            if (w && (y = M(w)) && (k.isAAC ? F(y) : N(y), E && k.codec && (A === -1 || _.codec))) return void this.remux(n, s, e, i);\n                            w = {\n                              data: [],\n                              size: 0\n                            };\n                          }\n\n                          w && (w.data.push(e.subarray(p, d + 188)), w.size += d + 188 - p);\n                          break;\n\n                        case L:\n                          f && (P && (y = M(P)) && U(y), P = {\n                            data: [],\n                            size: 0\n                          }), P && (P.data.push(e.subarray(p, d + 188)), P.size += d + 188 - p);\n                          break;\n\n                        case 0:\n                          f && (p += e[p] + 1), D = this._pmtId = C(e, p);\n                          break;\n\n                        case D:\n                          f && (p += e[p] + 1);\n                          var G = I(e, p, this.typeSupported.mpeg === !0 || this.typeSupported.mp3 === !0);\n                          A = G.avc, A > 0 && (_.id = A), S = G.audio, S > 0 && (k.id = S, k.isAAC = G.isAAC), L = G.id3, L > 0 && (T.id = L), b && !R && (h.logger.log(\"reparse from beginning\"), b = !1, d = -188), R = this.pmtParsed = !0;\n                          break;\n\n                        case 17:\n                        case 8191:\n                          break;\n\n                        default:\n                          b = !0;\n                      }\n                    } else this.observer.trigger(u.default.ERROR, {\n                      type: c.ErrorTypes.MEDIA_ERROR,\n                      id: this.id,\n                      details: c.ErrorDetails.FRAG_PARSING_ERROR,\n                      fatal: !1,\n                      reason: \"TS packet did not start with 0x47\"\n                    });\n                  }\n\n                  O && (y = M(O)) ? (x(y, !0), _.pesData = null) : _.pesData = O, w && (y = M(w)) ? (k.isAAC ? F(y) : N(y), k.pesData = null) : (w && w.size && h.logger.log(\"last AAC PES packet truncated,might overlap between fragments\"), k.pesData = w), P && (y = M(P)) ? (U(y), T.pesData = null) : T.pesData = P, this.remux(n, s, null, i);\n                }\n              }, {\n                key: \"remux\",\n                value: function value(e, t, r, i) {\n                  for (var a = this._avcTrack, n = a.samples, s = 0, o = 0, l = 0; n.length > l; l++) {\n                    for (var u = n[l], d = u.units.units, f = d.length, h = 0, c = 0; f > c; c++) {\n                      h += d[c].data.length;\n                    }\n\n                    o += h, s += f, u.length = h;\n                  }\n\n                  a.len = o, a.nbNalu = s, this.remuxer.remux(e, t, this._audioTrack, this._avcTrack, this._id3Track, this._txtTrack, i, this.contiguous, this.accurateTimeOffset, r);\n                }\n              }, {\n                key: \"destroy\",\n                value: function value() {\n                  this.switchLevel(), this._initPTS = this._initDTS = void 0, this._duration = 0;\n                }\n              }, {\n                key: \"_parsePAT\",\n                value: function value(e, t) {\n                  return (31 & e[t + 10]) << 8 | e[t + 11];\n                }\n              }, {\n                key: \"_parsePMT\",\n                value: function value(e, t, r) {\n                  var i,\n                      a,\n                      n,\n                      s,\n                      o = {\n                    audio: -1,\n                    avc: -1,\n                    id3: -1,\n                    isAAC: !0\n                  };\n\n                  for (i = (15 & e[t + 1]) << 8 | e[t + 2], a = t + 3 + i - 4, n = (15 & e[t + 10]) << 8 | e[t + 11], t += 12 + n; a > t;) {\n                    switch (s = (31 & e[t + 1]) << 8 | e[t + 2], e[t]) {\n                      case 15:\n                        o.audio === -1 && (o.audio = s);\n                        break;\n\n                      case 21:\n                        o.id3 === -1 && (o.id3 = s);\n                        break;\n\n                      case 27:\n                        o.avc === -1 && (o.avc = s);\n                        break;\n\n                      case 3:\n                      case 4:\n                        r ? o.audio === -1 && (o.audio = s, o.isAAC = !1) : h.logger.log(\"MPEG audio found, not supported in this browser for now\");\n                        break;\n\n                      case 36:\n                        h.logger.warn(\"HEVC stream type found, not supported for now\");\n                        break;\n\n                      default:\n                        h.logger.log(\"unkown stream type:\" + e[t]);\n                    }\n\n                    t += ((15 & e[t + 3]) << 8 | e[t + 4]) + 5;\n                  }\n\n                  return o;\n                }\n              }, {\n                key: \"_parsePES\",\n                value: function value(e) {\n                  var t,\n                      r,\n                      i,\n                      a,\n                      n,\n                      s,\n                      o,\n                      l,\n                      u,\n                      d = 0,\n                      f = e.data;\n                  if (!e || 0 === e.size) return null;\n\n                  for (; 19 > f[0].length && f.length > 1;) {\n                    var h = new Uint8Array(f[0].length + f[1].length);\n                    h.set(f[0]), h.set(f[1], f[0].length), f[0] = h, f.splice(1, 1);\n                  }\n\n                  if (t = f[0], i = (t[0] << 16) + (t[1] << 8) + t[2], 1 === i) {\n                    if (a = (t[4] << 8) + t[5], a && a > e.size - 6) return null;\n\n                    for (r = t[7], 192 & r && (o = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, o > 4294967295 && (o -= 8589934592), 64 & r ? (l = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2, l > 4294967295 && (l -= 8589934592)) : l = o), n = t[8], u = n + 9, e.size -= u, s = new Uint8Array(e.size); f.length;) {\n                      t = f.shift();\n                      var c = t.byteLength;\n\n                      if (u) {\n                        if (u > c) {\n                          u -= c;\n                          continue;\n                        }\n\n                        t = t.subarray(u), c -= u, u = 0;\n                      }\n\n                      s.set(t, d), d += c;\n                    }\n\n                    return a && (a -= n + 3), {\n                      data: s,\n                      pts: o,\n                      dts: l,\n                      len: a\n                    };\n                  }\n\n                  return null;\n                }\n              }, {\n                key: \"pushAccesUnit\",\n                value: function value(e, t) {\n                  e.units.units.length && e.frame && (!this.config.forceKeyFrameOnDiscontinuity || e.key === !0 || t.sps && (t.samples.length || this.contiguous) ? t.samples.push(e) : t.dropped++), e.debug.length && h.logger.log(e.pts + \"/\" + e.dts + \":\" + e.debug + \",\" + e.units.length);\n                }\n              }, {\n                key: \"_parseAVCPES\",\n                value: function value(e, t) {\n                  var r,\n                      i,\n                      a,\n                      n = this,\n                      s = this._avcTrack,\n                      o = this._parseAVCNALu(e.data),\n                      l = !1,\n                      u = this.avcSample;\n\n                  e.data = null, o.forEach(function (t) {\n                    switch (t.type) {\n                      case 1:\n                        i = !0, l && u && (u.debug += \"NDR \"), u.frame = !0;\n                        var o = t.data;\n\n                        if (o.length > 1) {\n                          var d = new f.default(o).readSliceType();\n                          2 !== d && 4 !== d && 7 !== d && 9 !== d || (u.key = !0);\n                        }\n\n                        break;\n\n                      case 5:\n                        i = !0, u || (u = n.avcSample = n._createAVCSample(!0, e.pts, e.dts, \"\")), l && (u.debug += \"IDR \"), u.key = !0, u.frame = !0;\n                        break;\n\n                      case 6:\n                        i = !0, l && u && (u.debug += \"SEI \"), r = new f.default(n.discardEPB(t.data)), r.readUByte();\n\n                        for (var h = 0, c = 0, v = !1, g = 0; !v && r.bytesAvailable > 1;) {\n                          h = 0;\n\n                          do {\n                            g = r.readUByte(), h += g;\n                          } while (255 === g);\n\n                          c = 0;\n\n                          do {\n                            g = r.readUByte(), c += g;\n                          } while (255 === g);\n\n                          if (4 === h && 0 !== r.bytesAvailable) {\n                            v = !0;\n                            var p = r.readUByte();\n\n                            if (181 === p) {\n                              var y = r.readUShort();\n\n                              if (49 === y) {\n                                var m = r.readUInt();\n\n                                if (1195456820 === m) {\n                                  var E = r.readUByte();\n\n                                  if (3 === E) {\n                                    var b = r.readUByte(),\n                                        R = r.readUByte(),\n                                        _ = 31 & b,\n                                        k = [b, R];\n\n                                    for (a = 0; _ > a; a++) {\n                                      k.push(r.readUByte()), k.push(r.readUByte()), k.push(r.readUByte());\n                                    }\n\n                                    n._insertSampleInOrder(n._txtTrack.samples, {\n                                      type: 3,\n                                      pts: e.pts,\n                                      bytes: k\n                                    });\n                                  }\n                                }\n                              }\n                            }\n                          } else if (r.bytesAvailable > c) for (a = 0; c > a; a++) {\n                            r.readUByte();\n                          }\n                        }\n\n                        break;\n\n                      case 7:\n                        if (i = !0, l && u && (u.debug += \"SPS \"), !s.sps) {\n                          r = new f.default(t.data);\n                          var T = r.readSPS();\n                          s.width = T.width, s.height = T.height, s.sps = [t.data], s.duration = n._duration;\n                          var A = t.data.subarray(1, 4),\n                              S = \"avc1.\";\n\n                          for (a = 0; 3 > a; a++) {\n                            var L = A[a].toString(16);\n                            2 > L.length && (L = \"0\" + L), S += L;\n                          }\n\n                          s.codec = S;\n                        }\n\n                        break;\n\n                      case 8:\n                        i = !0, l && u && (u.debug += \"PPS \"), s.pps || (s.pps = [t.data]);\n                        break;\n\n                      case 9:\n                        i = !1, u && n.pushAccesUnit(u, s), u = n.avcSample = n._createAVCSample(!1, e.pts, e.dts, l ? \"AUD \" : \"\");\n                        break;\n\n                      case 12:\n                        i = !1;\n                        break;\n\n                      default:\n                        i = !1, u && (u.debug += \"unknown NAL \" + t.type + \" \");\n                    }\n\n                    if (u && i) {\n                      var D = u.units;\n                      D.units.push(t);\n                    }\n                  }), t && u && (this.pushAccesUnit(u, s), this.avcSample = null);\n                }\n              }, {\n                key: \"_createAVCSample\",\n                value: function value(e, t, r, i) {\n                  return {\n                    key: e,\n                    pts: t,\n                    dts: r,\n                    units: {\n                      units: [],\n                      length: 0\n                    },\n                    debug: i\n                  };\n                }\n              }, {\n                key: \"_insertSampleInOrder\",\n                value: function value(e, t) {\n                  var r = e.length;\n                  if (r > 0) {\n                    if (t.pts < e[r - 1].pts) {\n                      for (var i = r - 1; i >= 0; i--) {\n                        if (e[i].pts > t.pts) {\n                          e.splice(i, 0, t);\n                          break;\n                        }\n                      }\n                    } else e.push(t);\n                  } else e.push(t);\n                }\n              }, {\n                key: \"_getLastNalUnit\",\n                value: function value() {\n                  var e = this.avcSample,\n                      t = void 0;\n\n                  if (!e || 0 === e.units.units.length) {\n                    var r = this._avcTrack,\n                        i = r.samples;\n                    e = i[i.length - 1];\n                  }\n\n                  if (e) {\n                    var a = e.units.units;\n                    t = a[a.length - 1];\n                  }\n\n                  return t;\n                }\n              }, {\n                key: \"_parseAVCNALu\",\n                value: function value(e) {\n                  for (var t, r, i, a, n, s = 0, o = e.byteLength, l = this._avcTrack, u = l.naluState || 0, d = u, f = [], h = -1; o > s;) {\n                    if (t = e[s++], u) {\n                      if (1 !== u) switch (u) {\n                        case 2:\n                        case 3:\n                          if (0 === t) u = 3;else if (1 === t) {\n                            if (h < 0) {\n                              var c = this._getLastNalUnit();\n\n                              if (c && (d && 4 - d >= s && c.state && (c.data = c.data.subarray(0, c.data.byteLength - d)), r = s - u - 1, r > 0)) {\n                                var v = new Uint8Array(c.data.byteLength + r);\n                                v.set(c.data, 0), v.set(e.subarray(0, r), c.data.byteLength), c.data = v;\n                              }\n                            } else i = {\n                              data: e.subarray(h, s - u - 1),\n                              type: n\n                            }, f.push(i);\n\n                            o > s ? (a = 31 & e[s], h = s, n = a, u = 0) : u = -1;\n                          } else u = 0;\n                          break;\n\n                        case -1:\n                          h = 0, n = 31 & t, u = 0;\n                      } else u = t ? 0 : 2;\n                    } else u = t ? 0 : 1;\n                  }\n\n                  if (0 > h || 0 > u || (i = {\n                    data: e.subarray(h, o),\n                    type: n,\n                    state: u\n                  }, f.push(i)), 0 === f.length) {\n                    var g = this._getLastNalUnit();\n\n                    if (g) {\n                      var p = new Uint8Array(g.data.byteLength + e.byteLength);\n                      p.set(g.data, 0), p.set(e, g.data.byteLength), g.data = p;\n                    }\n                  }\n\n                  return l.naluState = u, f;\n                }\n              }, {\n                key: \"discardEPB\",\n                value: function value(e) {\n                  for (var t, r, i = e.byteLength, a = [], n = 1; i - 2 > n;) {\n                    0 === e[n] && 0 === e[n + 1] && 3 === e[n + 2] ? (a.push(n + 2), n += 2) : n++;\n                  }\n\n                  if (0 === a.length) return e;\n                  t = i - a.length, r = new Uint8Array(t);\n                  var s = 0;\n\n                  for (n = 0; t > n; s++, n++) {\n                    s === a[0] && (s++, a.shift()), r[n] = e[s];\n                  }\n\n                  return r;\n                }\n              }, {\n                key: \"_parseAACPES\",\n                value: function value(e) {\n                  var t,\n                      r,\n                      i,\n                      a,\n                      n,\n                      s,\n                      l,\n                      d,\n                      f,\n                      v = this._audioTrack,\n                      g = e.data,\n                      p = e.pts,\n                      y = 0,\n                      m = this.aacOverFlow,\n                      E = this.aacLastPTS;\n\n                  if (m) {\n                    var b = new Uint8Array(m.byteLength + g.byteLength);\n                    b.set(m, 0), b.set(g, m.byteLength), g = b;\n                  }\n\n                  for (n = y, d = g.length; d - 1 > n && (255 !== g[n] || 240 !== (240 & g[n + 1])); n++) {\n                    ;\n                  }\n\n                  if (n) {\n                    var R, _;\n\n                    if (d - 1 > n ? (R = \"AAC PES did not start with ADTS header,offset:\" + n, _ = !1) : (R = \"no ADTS header found in AAC PES\", _ = !0), h.logger.warn(\"parsing error:\" + R), this.observer.trigger(u.default.ERROR, {\n                      type: c.ErrorTypes.MEDIA_ERROR,\n                      id: this.id,\n                      details: c.ErrorDetails.FRAG_PARSING_ERROR,\n                      fatal: _,\n                      reason: R\n                    }), _) return;\n                  }\n\n                  if (v.audiosamplerate || (t = o.default.getAudioConfig(this.observer, g, n, this.audioCodec), v.config = t.config, v.audiosamplerate = t.samplerate, v.channelCount = t.channelCount, v.codec = t.codec, v.duration = this._duration, h.logger.log(\"parsed codec:\" + v.codec + \",rate:\" + t.samplerate + \",nb channel:\" + t.channelCount)), a = 0, i = 9216e4 / v.audiosamplerate, m && E) {\n                    var k = E + i;\n                    Math.abs(k - p) > 1 && (h.logger.log(\"AAC: align PTS for overlapping frames by \" + Math.round((k - p) / 90)), p = k);\n                  }\n\n                  for (; d > n + 5 && (s = 1 & g[n + 1] ? 7 : 9, r = (3 & g[n + 3]) << 11 | g[n + 4] << 3 | (224 & g[n + 5]) >>> 5, r -= s, r > 0 && d >= n + s + r);) {\n                    for (l = p + a * i, f = {\n                      unit: g.subarray(n + s, n + s + r),\n                      pts: l,\n                      dts: l\n                    }, v.samples.push(f), v.len += r, n += r + s, a++; d - 1 > n && (255 !== g[n] || 240 !== (240 & g[n + 1])); n++) {\n                      ;\n                    }\n                  }\n\n                  m = d > n ? g.subarray(n, d) : null, this.aacOverFlow = m, this.aacLastPTS = l;\n                }\n              }, {\n                key: \"_parseMPEGPES\",\n                value: function value(e) {\n                  for (var t, r = e.data, i = e.pts, a = r.length, n = 0, s = 0; a > s && (t = this._parseMpeg(r, s, a, n++, i)) > 0;) {\n                    s += t;\n                  }\n                }\n              }, {\n                key: \"_onMpegFrame\",\n                value: function value(e, t, r, i, a, n) {\n                  var s = 1152 / r * 1e3,\n                      o = n + a * s,\n                      l = this._audioTrack;\n                  l.config = [], l.channelCount = i, l.audiosamplerate = r, l.duration = this._duration, l.samples.push({\n                    unit: e,\n                    pts: o,\n                    dts: o\n                  }), l.len += e.length;\n                }\n              }, {\n                key: \"_onMpegNoise\",\n                value: function value(e) {\n                  h.logger.warn(\"mpeg audio has noise: \" + e.length + \" bytes\");\n                }\n              }, {\n                key: \"_parseMpeg\",\n                value: function value(e, t, r, i, a) {\n                  var n = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],\n                      s = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];\n                  if (t + 2 > r) return -1;\n\n                  if (255 === e[t] || 224 === (224 & e[t + 1])) {\n                    if (t + 24 > r) return -1;\n                    var o = e[t + 1] >> 3 & 3,\n                        l = e[t + 1] >> 1 & 3,\n                        u = e[t + 2] >> 4 & 15,\n                        d = e[t + 2] >> 2 & 3,\n                        f = !!(2 & e[t + 2]);\n\n                    if (1 !== o && 0 !== u && 15 !== u && 3 !== d) {\n                      var h = 3 === o ? 3 - l : 3 === l ? 3 : 4,\n                          c = 1e3 * n[14 * h + u - 1],\n                          v = 3 === o ? 0 : 2 === o ? 1 : 2,\n                          g = s[3 * v + d],\n                          p = f ? 1 : 0,\n                          y = e[t + 3] >> 6 === 3 ? 1 : 2,\n                          m = 3 === l ? (3 === o ? 12 : 6) * c / g + p << 2 : (3 === o ? 144 : 72) * c / g + p | 0;\n                      return t + m > r ? -1 : (this._onMpegFrame && this._onMpegFrame(e.subarray(t, t + m), c, g, y, i, a), m);\n                    }\n                  }\n\n                  for (var E = t + 2; r > E;) {\n                    if (255 === e[E - 1] && 224 === (224 & e[E])) return this._onMpegNoise && this._onMpegNoise(e.subarray(t, E - 1)), E - t - 1;\n                    E++;\n                  }\n\n                  return -1;\n                }\n              }, {\n                key: \"_parseID3PES\",\n                value: function value(e) {\n                  this._id3Track.samples.push(e);\n                }\n              }], [{\n                key: \"probe\",\n                value: function value(e) {\n                  return e.length >= 564 && 71 === e[0] && 71 === e[188] && 71 === e[376];\n                }\n              }]), e;\n            }();\n\n            r.default = v;\n          }, {\n            19: 19,\n            23: 23,\n            26: 26,\n            28: 28,\n            45: 45\n          }],\n          26: [function (e, t, r) {\n            \"use strict\";\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n            r.ErrorTypes = {\n              NETWORK_ERROR: \"networkError\",\n              MEDIA_ERROR: \"mediaError\",\n              MUX_ERROR: \"muxError\",\n              OTHER_ERROR: \"otherError\"\n            }, r.ErrorDetails = {\n              MANIFEST_LOAD_ERROR: \"manifestLoadError\",\n              MANIFEST_LOAD_TIMEOUT: \"manifestLoadTimeOut\",\n              MANIFEST_PARSING_ERROR: \"manifestParsingError\",\n              MANIFEST_INCOMPATIBLE_CODECS_ERROR: \"manifestIncompatibleCodecsError\",\n              LEVEL_LOAD_ERROR: \"levelLoadError\",\n              LEVEL_LOAD_TIMEOUT: \"levelLoadTimeOut\",\n              LEVEL_SWITCH_ERROR: \"levelSwitchError\",\n              AUDIO_TRACK_LOAD_ERROR: \"audioTrackLoadError\",\n              AUDIO_TRACK_LOAD_TIMEOUT: \"audioTrackLoadTimeOut\",\n              FRAG_LOAD_ERROR: \"fragLoadError\",\n              FRAG_LOOP_LOADING_ERROR: \"fragLoopLoadingError\",\n              FRAG_LOAD_TIMEOUT: \"fragLoadTimeOut\",\n              FRAG_DECRYPT_ERROR: \"fragDecryptError\",\n              FRAG_PARSING_ERROR: \"fragParsingError\",\n              REMUX_ALLOC_ERROR: \"remuxAllocError\",\n              KEY_LOAD_ERROR: \"keyLoadError\",\n              KEY_LOAD_TIMEOUT: \"keyLoadTimeOut\",\n              BUFFER_ADD_CODEC_ERROR: \"bufferAddCodecError\",\n              BUFFER_APPEND_ERROR: \"bufferAppendError\",\n              BUFFER_APPENDING_ERROR: \"bufferAppendingError\",\n              BUFFER_STALLED_ERROR: \"bufferStalledError\",\n              BUFFER_FULL_ERROR: \"bufferFullError\",\n              BUFFER_SEEK_OVER_HOLE: \"bufferSeekOverHole\",\n              INTERNAL_EXCEPTION: \"internalException\"\n            };\n          }, {}],\n          27: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n              return typeof e;\n            } : function (e) {\n              return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n            },\n                s = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                o = e(45),\n                l = e(26),\n                u = e(28),\n                d = i(u),\n                f = function () {\n              function e(t) {\n                a(this, e), this.hls = t, this.onEvent = this.onEvent.bind(this);\n\n                for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), n = 1; r > n; n++) {\n                  i[n - 1] = arguments[n];\n                }\n\n                this.handledEvents = i, this.useGenericHandler = !0, this.registerListeners();\n              }\n\n              return s(e, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.unregisterListeners();\n                }\n              }, {\n                key: \"isEventHandler\",\n                value: function value() {\n                  return \"object\" === n(this.handledEvents) && this.handledEvents.length && \"function\" == typeof this.onEvent;\n                }\n              }, {\n                key: \"registerListeners\",\n                value: function value() {\n                  this.isEventHandler() && this.handledEvents.forEach(function (e) {\n                    if (\"hlsEventGeneric\" === e) throw Error(\"Forbidden event name: \" + e);\n                    this.hls.on(e, this.onEvent);\n                  }.bind(this));\n                }\n              }, {\n                key: \"unregisterListeners\",\n                value: function value() {\n                  this.isEventHandler() && this.handledEvents.forEach(function (e) {\n                    this.hls.off(e, this.onEvent);\n                  }.bind(this));\n                }\n              }, {\n                key: \"onEvent\",\n                value: function value(e, t) {\n                  this.onEventGeneric(e, t);\n                }\n              }, {\n                key: \"onEventGeneric\",\n                value: function value(e, t) {\n                  var r = function r(e, t) {\n                    var r = \"on\" + e.replace(\"hls\", \"\");\n                    if (\"function\" != typeof this[r]) throw Error(\"Event \" + e + \" has no generic handler in this \" + this.constructor.name + \" class (tried \" + r + \")\");\n                    return this[r].bind(this, t);\n                  };\n\n                  try {\n                    r.call(this, e, t).call();\n                  } catch (t) {\n                    o.logger.error(\"internal error happened while processing \" + e + \":\" + t.message), this.hls.trigger(d.default.ERROR, {\n                      type: l.ErrorTypes.OTHER_ERROR,\n                      details: l.ErrorDetails.INTERNAL_EXCEPTION,\n                      fatal: !1,\n                      event: e,\n                      err: t\n                    });\n                  }\n                }\n              }]), e;\n            }();\n\n            r.default = f;\n          }, {\n            26: 26,\n            28: 28,\n            45: 45\n          }],\n          28: [function (e, t, r) {\n            \"use strict\";\n\n            t.exports = {\n              MEDIA_ATTACHING: \"hlsMediaAttaching\",\n              MEDIA_ATTACHED: \"hlsMediaAttached\",\n              MEDIA_DETACHING: \"hlsMediaDetaching\",\n              MEDIA_DETACHED: \"hlsMediaDetached\",\n              BUFFER_RESET: \"hlsBufferReset\",\n              BUFFER_CODECS: \"hlsBufferCodecs\",\n              BUFFER_CREATED: \"hlsBufferCreated\",\n              BUFFER_APPENDING: \"hlsBufferAppending\",\n              BUFFER_APPENDED: \"hlsBufferAppended\",\n              BUFFER_EOS: \"hlsBufferEos\",\n              BUFFER_FLUSHING: \"hlsBufferFlushing\",\n              BUFFER_FLUSHED: \"hlsBufferFlushed\",\n              MANIFEST_LOADING: \"hlsManifestLoading\",\n              MANIFEST_LOADED: \"hlsManifestLoaded\",\n              MANIFEST_PARSED: \"hlsManifestParsed\",\n              LEVEL_LOADING: \"hlsLevelLoading\",\n              LEVEL_LOADED: \"hlsLevelLoaded\",\n              LEVEL_UPDATED: \"hlsLevelUpdated\",\n              LEVEL_PTS_UPDATED: \"hlsLevelPtsUpdated\",\n              LEVEL_SWITCH: \"hlsLevelSwitch\",\n              AUDIO_TRACKS_UPDATED: \"hlsAudioTracksUpdated\",\n              AUDIO_TRACK_SWITCH: \"hlsAudioTrackSwitch\",\n              AUDIO_TRACK_LOADING: \"hlsAudioTrackLoading\",\n              AUDIO_TRACK_LOADED: \"hlsAudioTrackLoaded\",\n              FRAG_LOADING: \"hlsFragLoading\",\n              FRAG_LOAD_PROGRESS: \"hlsFragLoadProgress\",\n              FRAG_LOAD_EMERGENCY_ABORTED: \"hlsFragLoadEmergencyAborted\",\n              FRAG_LOADED: \"hlsFragLoaded\",\n              FRAG_DECRYPTED: \"hlsFragDecrypted\",\n              FRAG_PARSING_INIT_SEGMENT: \"hlsFragParsingInitSegment\",\n              FRAG_PARSING_USERDATA: \"hlsFragParsingUserdata\",\n              FRAG_PARSING_METADATA: \"hlsFragParsingMetadata\",\n              FRAG_PARSING_DATA: \"hlsFragParsingData\",\n              FRAG_PARSED: \"hlsFragParsed\",\n              FRAG_BUFFERED: \"hlsFragBuffered\",\n              FRAG_CHANGED: \"hlsFragChanged\",\n              FPS_DROP: \"hlsFpsDrop\",\n              FPS_DROP_LEVEL_CAPPING: \"hlsFpsDropLevelCapping\",\n              ERROR: \"hlsError\",\n              DESTROYING: \"hlsDestroying\",\n              KEY_LOADING: \"hlsKeyLoading\",\n              KEY_LOADED: \"hlsKeyLoaded\",\n              STREAM_STATE_TRANSITION: \"hlsStreamStateTransition\"\n            };\n          }, {}],\n          29: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e() {\n                i(this, e);\n              }\n\n              return a(e, null, [{\n                key: \"getSilentFrame\",\n                value: function value(e) {\n                  return 1 === e ? new Uint8Array([0, 200, 0, 128, 35, 128]) : 2 === e ? new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]) : 3 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]) : 4 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]) : 5 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]) : 6 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) : null;\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          30: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e() {\n                i(this, e);\n              }\n\n              return a(e, null, [{\n                key: \"isBuffered\",\n                value: function value(e, t) {\n                  if (e) for (var r = e.buffered, i = 0; r.length > i; i++) {\n                    if (t >= r.start(i) && t <= r.end(i)) return !0;\n                  }\n                  return !1;\n                }\n              }, {\n                key: \"bufferInfo\",\n                value: function value(e, t, r) {\n                  if (e) {\n                    var i,\n                        a = e.buffered,\n                        n = [];\n\n                    for (i = 0; a.length > i; i++) {\n                      n.push({\n                        start: a.start(i),\n                        end: a.end(i)\n                      });\n                    }\n\n                    return this.bufferedInfo(n, t, r);\n                  }\n\n                  return {\n                    len: 0,\n                    start: 0,\n                    end: 0,\n                    nextStart: void 0\n                  };\n                }\n              }, {\n                key: \"bufferedInfo\",\n                value: function value(e, t, r) {\n                  var i,\n                      a,\n                      n,\n                      s,\n                      o,\n                      l = [];\n\n                  for (e.sort(function (e, t) {\n                    var r = e.start - t.start;\n                    return r ? r : t.end - e.end;\n                  }), o = 0; e.length > o; o++) {\n                    var u = l.length;\n\n                    if (u) {\n                      var d = l[u - 1].end;\n                      r > e[o].start - d ? e[o].end > d && (l[u - 1].end = e[o].end) : l.push(e[o]);\n                    } else l.push(e[o]);\n                  }\n\n                  for (o = 0, i = 0, a = n = t; l.length > o; o++) {\n                    var f = l[o].start,\n                        h = l[o].end;\n                    if (t + r >= f && h > t) a = f, n = h, i = n - t;else if (f > t + r) {\n                      s = f;\n                      break;\n                    }\n                  }\n\n                  return {\n                    len: i,\n                    start: a,\n                    end: n,\n                    nextStart: s\n                  };\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          31: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = e(45),\n                s = function () {\n              function e() {\n                i(this, e);\n              }\n\n              return a(e, null, [{\n                key: \"mergeDetails\",\n                value: function value(t, r) {\n                  var i,\n                      a = Math.max(t.startSN, r.startSN) - r.startSN,\n                      s = Math.min(t.endSN, r.endSN) - r.startSN,\n                      o = r.startSN - t.startSN,\n                      l = t.fragments,\n                      u = r.fragments,\n                      d = 0;\n                  if (a > s) return void (r.PTSKnown = !1);\n\n                  for (var f = a; s >= f; f++) {\n                    var h = l[o + f],\n                        c = u[f];\n                    c && h && (d = h.cc - c.cc, isNaN(h.startPTS) || (c.start = c.startPTS = h.startPTS, c.endPTS = h.endPTS, c.duration = h.duration, i = c));\n                  }\n\n                  if (d) for (n.logger.log(\"discontinuity sliding from playlist, take drift into account\"), f = 0; u.length > f; f++) {\n                    u[f].cc += d;\n                  }\n                  if (i) e.updateFragPTSDTS(r, i.sn, i.startPTS, i.endPTS, i.startDTS, i.endDTS);else if (o >= 0 && l.length > o) {\n                    var v = l[o].start;\n\n                    for (f = 0; u.length > f; f++) {\n                      u[f].start += v;\n                    }\n                  }\n                  r.PTSKnown = t.PTSKnown;\n                }\n              }, {\n                key: \"updateFragPTSDTS\",\n                value: function value(t, r, i, a, n, s) {\n                  var o, l, u, d;\n                  if (!t || t.startSN > r || r > t.endSN) return 0;\n\n                  if (o = r - t.startSN, l = t.fragments, u = l[o], !isNaN(u.startPTS)) {\n                    var f = Math.abs(u.startPTS - i);\n                    u.deltaPTS = isNaN(u.deltaPTS) ? f : Math.max(f, u.deltaPTS), i = Math.min(i, u.startPTS), a = Math.max(a, u.endPTS), n = Math.min(n, u.startDTS), s = Math.max(s, u.endDTS);\n                  }\n\n                  var h = i - u.start;\n\n                  for (u.start = u.startPTS = i, u.endPTS = a, u.startDTS = n, u.endDTS = s, u.duration = a - i, d = o; d > 0; d--) {\n                    e.updatePTS(l, d, d - 1);\n                  }\n\n                  for (d = o; l.length - 1 > d; d++) {\n                    e.updatePTS(l, d, d + 1);\n                  }\n\n                  return t.PTSKnown = !0, h;\n                }\n              }, {\n                key: \"updatePTS\",\n                value: function value(e, t, r) {\n                  var i = e[t],\n                      a = e[r],\n                      s = a.startPTS;\n                  isNaN(s) ? a.start = r > t ? i.start + i.duration : i.start - a.duration : r > t ? (i.duration = s - i.start, 0 > i.duration && n.logger.warn(\"negative duration computed for frag \" + i.sn + \",level \" + i.level + \", there should be some duration drift between playlist and fragment!\")) : (a.duration = i.start - s, 0 > a.duration && n.logger.warn(\"negative duration computed for frag \" + a.sn + \",level \" + a.level + \", there should be some duration drift between playlist and fragment!\"));\n                }\n              }]), e;\n            }();\n\n            r.default = s;\n          }, {\n            45: 45\n          }],\n          32: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(28),\n                o = i(s),\n                l = e(26),\n                u = e(36),\n                d = i(u),\n                f = e(34),\n                h = i(f),\n                c = e(4),\n                v = i(c),\n                g = e(7),\n                p = i(g),\n                y = e(8),\n                m = i(y),\n                E = e(5),\n                b = i(E),\n                R = e(12),\n                _ = i(R),\n                k = e(11),\n                T = i(k),\n                A = e(13),\n                S = i(A),\n                L = e(10),\n                D = i(L),\n                O = e(6),\n                w = i(O),\n                P = e(45),\n                C = e(47),\n                I = i(C),\n                M = e(1),\n                x = i(M),\n                F = e(35),\n                N = i(F),\n                U = e(43),\n                G = i(U),\n                B = function () {\n              function e() {\n                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n                a(this, e);\n                var r = e.DefaultConfig;\n                if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n\n                for (var i in r) {\n                  i in t || (t[i] = r[i]);\n                }\n\n                if (void 0 !== t.liveMaxLatencyDurationCount && t.liveSyncDurationCount >= t.liveMaxLatencyDurationCount) throw Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be gt \"liveSyncDurationCount\"');\n                if (void 0 !== t.liveMaxLatencyDuration && (t.liveSyncDuration >= t.liveMaxLatencyDuration || void 0 === t.liveSyncDuration)) throw Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be gt \"liveSyncDuration\"');\n                (0, P.enableLogs)(t.debug), this.config = t;\n                var n = this.observer = new x.default();\n                n.trigger = function (e) {\n                  for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; t > i; i++) {\n                    r[i - 1] = arguments[i];\n                  }\n\n                  n.emit.apply(n, [e, e].concat(r));\n                }, n.off = function (e) {\n                  for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; t > i; i++) {\n                    r[i - 1] = arguments[i];\n                  }\n\n                  n.removeListener.apply(n, [e].concat(r));\n                }, this.on = n.on.bind(n), this.off = n.off.bind(n), this.trigger = n.trigger.bind(n), this.playlistLoader = new d.default(this), this.fragmentLoader = new h.default(this), this.levelController = new T.default(this), this.abrController = new t.abrController(this), this.bufferController = new t.bufferController(this), this.capLevelController = new t.capLevelController(this), this.fpsController = new t.fpsController(this), this.streamController = new t.streamController(this), this.audioStreamController = new t.audioStreamController(this), this.timelineController = new t.timelineController(this), this.audioTrackController = new w.default(this), this.keyLoader = new N.default(this);\n              }\n\n              return n(e, null, [{\n                key: \"isSupported\",\n                value: function value() {\n                  return window.MediaSource = window.MediaSource || window.WebKitMediaSource, window.MediaSource && \"function\" == typeof window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n                }\n              }, {\n                key: \"version\",\n                get: function get() {\n                  return \"0.6.14\";\n                }\n              }, {\n                key: \"Events\",\n                get: function get() {\n                  return o.default;\n                }\n              }, {\n                key: \"ErrorTypes\",\n                get: function get() {\n                  return l.ErrorTypes;\n                }\n              }, {\n                key: \"ErrorDetails\",\n                get: function get() {\n                  return l.ErrorDetails;\n                }\n              }, {\n                key: \"DefaultConfig\",\n                get: function get() {\n                  return e.defaultConfig || (e.defaultConfig = {\n                    autoStartLoad: !0,\n                    startPosition: -1,\n                    defaultAudioCodec: void 0,\n                    debug: !1,\n                    capLevelOnFPSDrop: !1,\n                    capLevelToPlayerSize: !1,\n                    initialLiveManifestSize: 1,\n                    maxBufferLength: 30,\n                    maxBufferSize: 6e7,\n                    maxBufferHole: .5,\n                    maxSeekHole: 2,\n                    seekHoleNudgeDuration: .01,\n                    stalledInBufferedNudgeThreshold: 10,\n                    maxFragLookUpTolerance: .2,\n                    liveSyncDurationCount: 3,\n                    liveMaxLatencyDurationCount: 1 / 0,\n                    liveSyncDuration: void 0,\n                    liveMaxLatencyDuration: void 0,\n                    maxMaxBufferLength: 600,\n                    enableWorker: !0,\n                    enableSoftwareAES: !0,\n                    enableLazyURLResolve: !1,\n                    manifestLoadingTimeOut: 1e4,\n                    manifestLoadingMaxRetry: 1,\n                    manifestLoadingRetryDelay: 1e3,\n                    manifestLoadingMaxRetryTimeout: 64e3,\n                    startLevel: void 0,\n                    levelLoadingTimeOut: 1e4,\n                    levelLoadingMaxRetry: 4,\n                    levelLoadingRetryDelay: 1e3,\n                    levelLoadingMaxRetryTimeout: 64e3,\n                    fragLoadingTimeOut: 2e4,\n                    fragLoadingMaxRetry: 6,\n                    fragLoadingRetryDelay: 1e3,\n                    fragLoadingMaxRetryTimeout: 64e3,\n                    fragLoadingLoopThreshold: 3,\n                    startFragPrefetch: !1,\n                    fpsDroppedMonitoringPeriod: 5e3,\n                    fpsDroppedMonitoringThreshold: .2,\n                    appendErrorMaxRetry: 3,\n                    loader: I.default,\n                    fLoader: void 0,\n                    pLoader: void 0,\n                    xhrSetup: void 0,\n                    fetchSetup: void 0,\n                    abrController: v.default,\n                    bufferController: p.default,\n                    capLevelController: m.default,\n                    fpsController: D.default,\n                    streamController: _.default,\n                    audioStreamController: b.default,\n                    timelineController: S.default,\n                    cueHandler: G.default,\n                    enableCEA708Captions: !0,\n                    enableMP2TPassThrough: !1,\n                    stretchShortVideoTrack: !1,\n                    forceKeyFrameOnDiscontinuity: !0,\n                    abrEwmaFastLive: 3,\n                    abrEwmaSlowLive: 9,\n                    abrEwmaFastVoD: 3,\n                    abrEwmaSlowVoD: 9,\n                    abrEwmaDefaultEstimate: 5e5,\n                    abrBandWidthFactor: .95,\n                    abrBandWidthUpFactor: .7,\n                    maxStarvationDelay: 4,\n                    maxLoadingDelay: 4,\n                    minAutoBitrate: 0\n                  }), e.defaultConfig;\n                },\n                set: function set(t) {\n                  e.defaultConfig = t;\n                }\n              }]), n(e, [{\n                key: \"destroy\",\n                value: function value() {\n                  P.logger.log(\"destroy\"), this.trigger(o.default.DESTROYING), this.detachMedia(), this.playlistLoader.destroy(), this.fragmentLoader.destroy(), this.levelController.destroy(), this.abrController.destroy(), this.bufferController.destroy(), this.capLevelController.destroy(), this.fpsController.destroy(), this.streamController.destroy(), this.audioStreamController.destroy(), this.timelineController.destroy(), this.audioTrackController.destroy(), this.keyLoader.destroy(), this.url = null, this.observer.removeAllListeners();\n                }\n              }, {\n                key: \"attachMedia\",\n                value: function value(e) {\n                  P.logger.log(\"attachMedia\"), this.media = e, this.trigger(o.default.MEDIA_ATTACHING, {\n                    media: e\n                  });\n                }\n              }, {\n                key: \"detachMedia\",\n                value: function value() {\n                  P.logger.log(\"detachMedia\"), this.trigger(o.default.MEDIA_DETACHING), this.media = null;\n                }\n              }, {\n                key: \"loadSource\",\n                value: function value(e) {\n                  P.logger.log(\"loadSource:\" + e), this.url = e, this.trigger(o.default.MANIFEST_LOADING, {\n                    url: e\n                  });\n                }\n              }, {\n                key: \"startLoad\",\n                value: function value() {\n                  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;\n                  P.logger.log(\"startLoad(\" + e + \")\"), this.levelController.startLoad(), this.streamController.startLoad(e), this.audioStreamController.startLoad(e);\n                }\n              }, {\n                key: \"stopLoad\",\n                value: function value() {\n                  P.logger.log(\"stopLoad\"), this.levelController.stopLoad(), this.streamController.stopLoad(), this.audioStreamController.stopLoad();\n                }\n              }, {\n                key: \"swapAudioCodec\",\n                value: function value() {\n                  P.logger.log(\"swapAudioCodec\"), this.streamController.swapAudioCodec();\n                }\n              }, {\n                key: \"recoverMediaError\",\n                value: function value() {\n                  P.logger.log(\"recoverMediaError\");\n                  var e = this.media;\n                  this.detachMedia(), this.attachMedia(e);\n                }\n              }, {\n                key: \"levels\",\n                get: function get() {\n                  return this.levelController.levels;\n                }\n              }, {\n                key: \"currentLevel\",\n                get: function get() {\n                  return this.streamController.currentLevel;\n                },\n                set: function set(e) {\n                  P.logger.log(\"set currentLevel:\" + e), this.loadLevel = e, this.streamController.immediateLevelSwitch();\n                }\n              }, {\n                key: \"nextLevel\",\n                get: function get() {\n                  return this.streamController.nextLevel;\n                },\n                set: function set(e) {\n                  P.logger.log(\"set nextLevel:\" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();\n                }\n              }, {\n                key: \"loadLevel\",\n                get: function get() {\n                  return this.levelController.level;\n                },\n                set: function set(e) {\n                  P.logger.log(\"set loadLevel:\" + e), this.levelController.manualLevel = e;\n                }\n              }, {\n                key: \"nextLoadLevel\",\n                get: function get() {\n                  return this.levelController.nextLoadLevel;\n                },\n                set: function set(e) {\n                  this.levelController.nextLoadLevel = e;\n                }\n              }, {\n                key: \"firstLevel\",\n                get: function get() {\n                  return Math.max(this.levelController.firstLevel, this.abrController.minAutoLevel);\n                },\n                set: function set(e) {\n                  P.logger.log(\"set firstLevel:\" + e), this.levelController.firstLevel = e;\n                }\n              }, {\n                key: \"startLevel\",\n                get: function get() {\n                  return this.levelController.startLevel;\n                },\n                set: function set(e) {\n                  P.logger.log(\"set startLevel:\" + e), this.levelController.startLevel = e;\n                }\n              }, {\n                key: \"autoLevelCapping\",\n                get: function get() {\n                  return this.abrController.autoLevelCapping;\n                },\n                set: function set(e) {\n                  P.logger.log(\"set autoLevelCapping:\" + e), this.abrController.autoLevelCapping = e;\n                }\n              }, {\n                key: \"autoLevelEnabled\",\n                get: function get() {\n                  return this.levelController.manualLevel === -1;\n                }\n              }, {\n                key: \"manualLevel\",\n                get: function get() {\n                  return this.levelController.manualLevel;\n                }\n              }, {\n                key: \"audioTracks\",\n                get: function get() {\n                  return this.audioTrackController.audioTracks;\n                }\n              }, {\n                key: \"audioTrack\",\n                get: function get() {\n                  return this.audioTrackController.audioTrack;\n                },\n                set: function set(e) {\n                  this.audioTrackController.audioTrack = e;\n                }\n              }, {\n                key: \"liveSyncPosition\",\n                get: function get() {\n                  return this.streamController.liveSyncPosition;\n                }\n              }]), e;\n            }();\n\n            r.default = B;\n          }, {\n            1: 1,\n            10: 10,\n            11: 11,\n            12: 12,\n            13: 13,\n            26: 26,\n            28: 28,\n            34: 34,\n            35: 35,\n            36: 36,\n            4: 4,\n            43: 43,\n            45: 45,\n            47: 47,\n            5: 5,\n            6: 6,\n            7: 7,\n            8: 8\n          }],\n          33: [function (e, t, r) {\n            \"use strict\";\n\n            t.exports = e(32).default;\n          }, {\n            32: 32\n          }],\n          34: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(26),\n                c = e(45),\n                v = e(2),\n                g = i(v),\n                p = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.FRAG_LOADING));\n                return r.loaders = {}, r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  var e = this.loaders;\n\n                  for (var t in e) {\n                    var r = e[t];\n                    r && r.destroy();\n                  }\n\n                  this.loaders = {}, f.default.prototype.destroy.call(this);\n                }\n              }, {\n                key: \"onFragLoading\",\n                value: function value(e) {\n                  var t = e.frag,\n                      r = t.type,\n                      i = this.loaders[r],\n                      a = this.hls.config;\n                  t.loaded = 0, i && (c.logger.warn(\"abort previous fragment loader for type:\" + r), i.abort()), i = this.loaders[r] = t.loader = void 0 !== a.fLoader ? new a.fLoader(a) : new a.loader(a);\n                  var n = void 0,\n                      s = void 0,\n                      o = void 0,\n                      l = t.url ? t.url : g.default.buildAbsoluteURL(t.baseurl, t.relurl);\n                  n = {\n                    url: l,\n                    frag: t,\n                    responseType: \"arraybuffer\",\n                    progressData: !1\n                  };\n                  var u = t.byteRangeStartOffset,\n                      d = t.byteRangeEndOffset;\n                  isNaN(u) || isNaN(d) || (n.rangeStart = u, n.rangeEnd = d), s = {\n                    timeout: a.fragLoadingTimeOut,\n                    maxRetry: 0,\n                    retryDelay: 0,\n                    maxRetryDelay: a.fragLoadingMaxRetryTimeout\n                  }, o = {\n                    onSuccess: this.loadsuccess.bind(this),\n                    onError: this.loaderror.bind(this),\n                    onTimeout: this.loadtimeout.bind(this),\n                    onProgress: this.loadprogress.bind(this)\n                  }, i.load(n, s, o);\n                }\n              }, {\n                key: \"loadsuccess\",\n                value: function value(e, t, r) {\n                  var i = e.data,\n                      a = r.frag;\n                  a.loader = void 0, this.loaders[a.type] = void 0, this.hls.trigger(u.default.FRAG_LOADED, {\n                    payload: i,\n                    frag: a,\n                    stats: t\n                  });\n                }\n              }, {\n                key: \"loaderror\",\n                value: function value(e, t) {\n                  var r = t.loader;\n                  r && r.abort(), this.loaders[t.type] = void 0, this.hls.trigger(u.default.ERROR, {\n                    type: h.ErrorTypes.NETWORK_ERROR,\n                    details: h.ErrorDetails.FRAG_LOAD_ERROR,\n                    fatal: !1,\n                    frag: t.frag,\n                    response: e\n                  });\n                }\n              }, {\n                key: \"loadtimeout\",\n                value: function value(e, t) {\n                  var r = t.loader;\n                  r && r.abort(), this.loaders[t.type] = void 0, this.hls.trigger(u.default.ERROR, {\n                    type: h.ErrorTypes.NETWORK_ERROR,\n                    details: h.ErrorDetails.FRAG_LOAD_TIMEOUT,\n                    fatal: !1,\n                    frag: t.frag\n                  });\n                }\n              }, {\n                key: \"loadprogress\",\n                value: function value(e, t, r) {\n                  var i = t.frag;\n                  i.loaded = e.loaded, this.hls.trigger(u.default.FRAG_LOAD_PROGRESS, {\n                    frag: i,\n                    stats: e\n                  });\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = p;\n          }, {\n            2: 2,\n            26: 26,\n            27: 27,\n            28: 28,\n            45: 45\n          }],\n          35: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(28),\n                u = i(l),\n                d = e(27),\n                f = i(d),\n                h = e(26),\n                c = e(45),\n                v = e(2),\n                g = i(v),\n                p = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, u.default.KEY_LOADING));\n                return r.loaders = {}, r.decryptkey = null, r.decrypturl = null, r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  for (var e in this.loaders) {\n                    var t = this.loaders[e];\n                    t && t.destroy();\n                  }\n\n                  this.loaders = {}, f.default.prototype.destroy.call(this);\n                }\n              }, {\n                key: \"onKeyLoading\",\n                value: function value(e) {\n                  var t = e.frag,\n                      r = t.type,\n                      i = this.loaders[r],\n                      a = t.decryptdata,\n                      n = a.uri ? a.uri : g.default.buildAbsoluteURL(a.baseuri, a.reluri);\n\n                  if (n !== this.decrypturl || null === this.decryptkey) {\n                    var s = this.hls.config;\n                    i && (c.logger.warn(\"abort previous key loader for type:\" + r), i.abort()), t.loader = this.loaders[r] = new s.loader(s), this.decrypturl = n, this.decryptkey = null;\n                    var o = void 0,\n                        l = void 0,\n                        d = void 0;\n                    o = {\n                      url: n,\n                      frag: t,\n                      responseType: \"arraybuffer\"\n                    }, l = {\n                      timeout: s.fragLoadingTimeOut,\n                      maxRetry: s.fragLoadingMaxRetry,\n                      retryDelay: s.fragLoadingRetryDelay,\n                      maxRetryDelay: s.fragLoadingMaxRetryTimeout\n                    }, d = {\n                      onSuccess: this.loadsuccess.bind(this),\n                      onError: this.loaderror.bind(this),\n                      onTimeout: this.loadtimeout.bind(this)\n                    }, t.loader.load(o, l, d);\n                  } else this.decryptkey && (a.key = this.decryptkey, this.hls.trigger(u.default.KEY_LOADED, {\n                    frag: t\n                  }));\n                }\n              }, {\n                key: \"loadsuccess\",\n                value: function value(e, t, r) {\n                  var i = r.frag;\n                  this.decryptkey = i.decryptdata.key = new Uint8Array(e.data), i.loader = void 0, this.loaders[i.type] = void 0, this.hls.trigger(u.default.KEY_LOADED, {\n                    frag: i\n                  });\n                }\n              }, {\n                key: \"loaderror\",\n                value: function value(e, t) {\n                  var r = t.frag,\n                      i = r.loader;\n                  i && i.abort(), this.loaders[t.type] = void 0, this.hls.trigger(u.default.ERROR, {\n                    type: h.ErrorTypes.NETWORK_ERROR,\n                    details: h.ErrorDetails.KEY_LOAD_ERROR,\n                    fatal: !1,\n                    frag: r,\n                    response: e\n                  });\n                }\n              }, {\n                key: \"loadtimeout\",\n                value: function value(e, t) {\n                  var r = t.frag,\n                      i = r.loader;\n                  i && i.abort(), this.loaders[t.type] = void 0, this.hls.trigger(u.default.ERROR, {\n                    type: h.ErrorTypes.NETWORK_ERROR,\n                    details: h.ErrorDetails.KEY_LOAD_TIMEOUT,\n                    fatal: !1,\n                    frag: r\n                  });\n                }\n              }]), t;\n            }(f.default);\n\n            r.default = p;\n          }, {\n            2: 2,\n            26: 26,\n            27: 27,\n            28: 28,\n            45: 45\n          }],\n          36: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            function n(e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }\n\n            function s(e, t) {\n              if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n              e.prototype = Object.create(t && t.prototype, {\n                constructor: {\n                  value: e,\n                  enumerable: !1,\n                  writable: !0,\n                  configurable: !0\n                }\n              }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var o = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                l = e(2),\n                u = i(l),\n                d = e(28),\n                f = i(d),\n                h = e(27),\n                c = i(h),\n                v = e(26),\n                g = e(40),\n                p = i(g),\n                y = e(45),\n                m = /#EXT-X-STREAM-INF:([^\\n\\r]*)[\\r\\n]+([^\\r\\n]+)/g,\n                E = /#EXT-X-MEDIA:(.*)/g,\n                b = /(?:#EXT(INF): *(\\d*(?:\\.\\d+)?)(?:,(.*))?)|(?:(?!#)()(\\S.+))|(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\\d+))|(?:#EXT-X-(TARGETDURATION): *(\\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(BYTERANGE): *(\\d+(?:@\\d+(?:\\.\\d+)?)?)|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(PROGRAM-DATE-TIME):(.+))|(?:#EXT-X-(VERSION):(\\d+))|(?:(#)(.*):(.*))|(?:(#)(.*)))(?:.*)\\r?\\n?/g,\n                R = function (e) {\n              function t(e) {\n                a(this, t);\n                var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, f.default.MANIFEST_LOADING, f.default.LEVEL_LOADING, f.default.AUDIO_TRACK_LOADING));\n                return r.loaders = {}, r;\n              }\n\n              return s(t, e), o(t, [{\n                key: \"destroy\",\n                value: function value() {\n                  for (var e in this.loaders) {\n                    var t = this.loaders[e];\n                    t && t.destroy();\n                  }\n\n                  this.loaders = {}, c.default.prototype.destroy.call(this);\n                }\n              }, {\n                key: \"onManifestLoading\",\n                value: function value(e) {\n                  this.load(e.url, {\n                    type: \"manifest\"\n                  });\n                }\n              }, {\n                key: \"onLevelLoading\",\n                value: function value(e) {\n                  this.load(e.url, {\n                    type: \"level\",\n                    level: e.level,\n                    id: e.id\n                  });\n                }\n              }, {\n                key: \"onAudioTrackLoading\",\n                value: function value(e) {\n                  this.load(e.url, {\n                    type: \"audioTrack\",\n                    id: e.id\n                  });\n                }\n              }, {\n                key: \"load\",\n                value: function value(e, t) {\n                  var r = this.loaders[t.type];\n\n                  if (r) {\n                    var i = r.context;\n                    if (i && i.url === e) return void y.logger.trace(\"playlist request ongoing\");\n                    y.logger.warn(\"abort previous loader for type:\" + t.type), r.abort();\n                  }\n\n                  var a = this.hls.config,\n                      n = void 0,\n                      s = void 0,\n                      o = void 0,\n                      l = void 0;\n                  \"manifest\" === t.type ? (n = a.manifestLoadingMaxRetry, s = a.manifestLoadingTimeOut, o = a.manifestLoadingRetryDelay, l = a.manifestLoadingMaxRetryTimeout) : (n = a.levelLoadingMaxRetry, s = a.levelLoadingTimeOut, o = a.levelLoadingRetryDelay, l = a.levelLoadingMaxRetryTimeout, y.logger.log(\"loading playlist for level \" + t.level)), r = this.loaders[t.type] = t.loader = void 0 !== a.pLoader ? new a.pLoader(a) : new a.loader(a), t.url = e, t.responseType = \"\";\n                  var u = void 0,\n                      d = void 0;\n                  u = {\n                    timeout: s,\n                    maxRetry: n,\n                    retryDelay: o,\n                    maxRetryDelay: l\n                  }, d = {\n                    onSuccess: this.loadsuccess.bind(this),\n                    onError: this.loaderror.bind(this),\n                    onTimeout: this.loadtimeout.bind(this)\n                  }, r.load(t, u, d);\n                }\n              }, {\n                key: \"resolve\",\n                value: function value(e, t) {\n                  return u.default.buildAbsoluteURL(t, e);\n                }\n              }, {\n                key: \"parseMasterPlaylist\",\n                value: function value(e, t) {\n                  var r = [],\n                      i = void 0;\n\n                  for (m.lastIndex = 0; null != (i = m.exec(e));) {\n                    var a = {},\n                        n = a.attrs = new p.default(i[1]);\n                    a.url = this.resolve(i[2], t);\n                    var s = n.decimalResolution(\"RESOLUTION\");\n                    s && (a.width = s.width, a.height = s.height), a.bitrate = n.decimalInteger(\"AVERAGE-BANDWIDTH\") || n.decimalInteger(\"BANDWIDTH\"), a.name = n.NAME;\n                    var o = n.CODECS;\n\n                    if (o) {\n                      o = o.split(/[ ,]+/);\n\n                      for (var l = 0; o.length > l; l++) {\n                        var u = o[l];\n                        u.indexOf(\"avc1\") !== -1 ? a.videoCodec = this.avc1toavcoti(u) : a.audioCodec = u;\n                      }\n                    }\n\n                    r.push(a);\n                  }\n\n                  return r;\n                }\n              }, {\n                key: \"parseMasterPlaylistMedia\",\n                value: function value(e, t, r) {\n                  var i = void 0,\n                      a = [];\n\n                  for (E.lastIndex = 0; null != (i = E.exec(e));) {\n                    var n = {},\n                        s = new p.default(i[1]);\n                    s.TYPE === r && (n.groupId = s[\"GROUP-ID\"], n.name = s.NAME, n.type = r, n.default = \"YES\" === s.DEFAULT, n.autoselect = \"YES\" === s.AUTOSELECT, n.forced = \"YES\" === s.FORCED, s.URI && (n.url = this.resolve(s.URI, t)), n.lang = s.LANGUAGE, n.name || (n.name = n.lang), a.push(n));\n                  }\n\n                  return a;\n                }\n              }, {\n                key: \"createInitializationVector\",\n                value: function value(e) {\n                  for (var t = new Uint8Array(16), r = 12; 16 > r; r++) {\n                    t[r] = e >> 8 * (15 - r) & 255;\n                  }\n\n                  return t;\n                }\n              }, {\n                key: \"fragmentDecryptdataFromLevelkey\",\n                value: function value(e, t) {\n                  var r = e;\n                  return e && e.method && e.uri && !e.iv && (r = this.cloneObj(e), r.iv = this.createInitializationVector(t)), r;\n                }\n              }, {\n                key: \"avc1toavcoti\",\n                value: function value(e) {\n                  var t,\n                      r = e.split(\".\");\n                  return r.length > 2 ? (t = r.shift() + \".\", t += parseInt(r.shift()).toString(16), t += (\"000\" + parseInt(r.shift()).toString(16)).substr(-4)) : t = e, t;\n                }\n              }, {\n                key: \"cloneObj\",\n                value: function value(e) {\n                  return JSON.parse(JSON.stringify(e));\n                }\n              }, {\n                key: \"parseLevelPlaylist\",\n                value: function value(e, t, r, i) {\n                  var a,\n                      n,\n                      s,\n                      o = 0,\n                      l = 0,\n                      u = {\n                    type: null,\n                    version: null,\n                    url: t,\n                    fragments: [],\n                    live: !0,\n                    startSN: 0\n                  },\n                      d = {\n                    method: null,\n                    key: null,\n                    iv: null,\n                    uri: null\n                  },\n                      f = 0,\n                      h = null,\n                      c = null,\n                      v = null,\n                      g = null,\n                      m = null,\n                      E = null,\n                      R = [],\n                      _ = this.hls.config,\n                      k = !!_ && _.enableLazyURLResolve;\n\n                  for (b.lastIndex = 0; null !== (n = b.exec(e));) {\n                    for (s = 1; n.length > s && void 0 === n[s]; s++) {\n                      ;\n                    }\n\n                    var T = n[s],\n                        A = n[s + 1],\n                        S = n[s + 2];\n\n                    switch (T) {\n                      case \"PLAYLIST-TYPE\":\n                        u.type = A.toUpperCase();\n                        break;\n\n                      case \"MEDIA-SEQUENCE\":\n                        o = u.startSN = parseInt(A);\n                        break;\n\n                      case \"TARGETDURATION\":\n                        u.targetduration = parseFloat(A);\n                        break;\n\n                      case \"VERSION\":\n                        u.version = parseInt(A);\n                        break;\n\n                      case \"EXTM3U\":\n                        break;\n\n                      case \"ENDLIST\":\n                        u.live = !1;\n                        break;\n\n                      case \"DIS\":\n                        f++, R.push([T]);\n                        break;\n\n                      case \"DISCONTINUITY-SEQ\":\n                        f = parseInt(A);\n                        break;\n\n                      case \"BYTERANGE\":\n                        var L = A.split(\"@\");\n                        E = 1 === L.length ? m : parseInt(L[1]), m = parseInt(L[0]) + E;\n                        break;\n\n                      case \"INF\":\n                        v = parseFloat(A), g = S ? S : null, R.push(S ? [T, A, S] : [T, A]);\n                        break;\n\n                      case \"\":\n                        if (!isNaN(v)) {\n                          var D = o++;\n                          a = this.fragmentDecryptdataFromLevelkey(d, D), c = {\n                            type: i,\n                            duration: v,\n                            title: g,\n                            start: l,\n                            sn: D,\n                            level: r,\n                            cc: f,\n                            decryptdata: a,\n                            programDateTime: h,\n                            tagList: R\n                          }, k ? (c.relurl = A, c.baseurl = t) : c.url = A ? this.resolve(A, t) : null, null !== E && (c.byteRangeStartOffset = E, c.byteRangeEndOffset = m), u.fragments.push(c), l += v, v = null, g = null, E = null, h = null, R = [];\n                        }\n\n                        break;\n\n                      case \"KEY\":\n                        var O = A,\n                            w = new p.default(O),\n                            P = w.enumeratedString(\"METHOD\"),\n                            C = w.URI,\n                            I = w.hexadecimalInteger(\"IV\");\n                        P && (d = {\n                          method: null,\n                          key: null,\n                          iv: null,\n                          uri: null\n                        }, C && \"AES-128\" === P && (d.method = P, k ? (d.baseuri = t, d.reluri = C) : d.uri = this.resolve(C, t), d.key = null, d.iv = I));\n                        break;\n\n                      case \"START\":\n                        var M = A,\n                            x = new p.default(M),\n                            F = x.decimalFloatingPoint(\"TIME-OFFSET\");\n                        isNaN(F) || (u.startTimeOffset = F);\n                        break;\n\n                      case \"PROGRAM-DATE-TIME\":\n                        h = new Date(Date.parse(A)), R.push([T, A]);\n                        break;\n\n                      case \"#\":\n                        R.push(S ? [A, S] : [A]);\n                        break;\n\n                      default:\n                        y.logger.warn(\"line parsed but not handled: \" + n);\n                    }\n                  }\n\n                  return !c || c.url || c.relurl || (u.fragments.pop(), l -= c.duration), u.totalduration = l, u.averagetargetduration = l / u.fragments.length, u.endSN = o - 1, u;\n                }\n              }, {\n                key: \"loadsuccess\",\n                value: function value(e, t, r) {\n                  var i = e.data,\n                      a = e.url,\n                      n = r.type,\n                      s = r.id,\n                      o = r.level,\n                      l = this.hls;\n                  if (this.loaders[n] = void 0, void 0 !== a && 0 !== a.indexOf(\"data:\") || (a = r.url), t.tload = performance.now(), 0 === i.indexOf(\"#EXTM3U\")) {\n                    if (i.indexOf(\"#EXTINF:\") > 0) {\n                      var u = \"audioTrack\" !== n,\n                          d = this.parseLevelPlaylist(i, a, (u ? o : s) || 0, u ? \"main\" : \"audio\");\n                      \"manifest\" === n && l.trigger(f.default.MANIFEST_LOADED, {\n                        levels: [{\n                          url: a,\n                          details: d\n                        }],\n                        audioTracks: [],\n                        url: a,\n                        stats: t\n                      }), t.tparsed = performance.now(), d.targetduration ? u ? l.trigger(f.default.LEVEL_LOADED, {\n                        details: d,\n                        level: o || 0,\n                        id: s || 0,\n                        stats: t\n                      }) : l.trigger(f.default.AUDIO_TRACK_LOADED, {\n                        details: d,\n                        id: s,\n                        stats: t\n                      }) : l.trigger(f.default.ERROR, {\n                        type: v.ErrorTypes.NETWORK_ERROR,\n                        details: v.ErrorDetails.MANIFEST_PARSING_ERROR,\n                        fatal: !0,\n                        url: a,\n                        reason: \"invalid targetduration\"\n                      });\n                    } else {\n                      var h = this.parseMasterPlaylist(i, a);\n\n                      if (h.length) {\n                        var c = this.parseMasterPlaylistMedia(i, a, \"AUDIO\");\n\n                        if (c.length) {\n                          var g = !1;\n                          c.forEach(function (e) {\n                            e.url || (g = !0);\n                          }), g === !1 && h[0].audioCodec && !h[0].attrs.AUDIO && (y.logger.log(\"audio codec signaled in quality level, but no embedded audio track signaled, create one\"), c.unshift({\n                            type: \"main\",\n                            name: \"main\"\n                          }));\n                        }\n\n                        l.trigger(f.default.MANIFEST_LOADED, {\n                          levels: h,\n                          audioTracks: c,\n                          url: a,\n                          stats: t\n                        });\n                      } else l.trigger(f.default.ERROR, {\n                        type: v.ErrorTypes.NETWORK_ERROR,\n                        details: v.ErrorDetails.MANIFEST_PARSING_ERROR,\n                        fatal: !0,\n                        url: a,\n                        reason: \"no level found in manifest\"\n                      });\n                    }\n                  } else l.trigger(f.default.ERROR, {\n                    type: v.ErrorTypes.NETWORK_ERROR,\n                    details: v.ErrorDetails.MANIFEST_PARSING_ERROR,\n                    fatal: !0,\n                    url: a,\n                    reason: \"no EXTM3U delimiter\"\n                  });\n                }\n              }, {\n                key: \"loaderror\",\n                value: function value(e, t) {\n                  var r,\n                      i,\n                      a = t.loader;\n\n                  switch (t.type) {\n                    case \"manifest\":\n                      r = v.ErrorDetails.MANIFEST_LOAD_ERROR, i = !0;\n                      break;\n\n                    case \"level\":\n                      r = v.ErrorDetails.LEVEL_LOAD_ERROR, i = !1;\n                      break;\n\n                    case \"audioTrack\":\n                      r = v.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, i = !1;\n                  }\n\n                  a && (a.abort(), this.loaders[t.type] = void 0), this.hls.trigger(f.default.ERROR, {\n                    type: v.ErrorTypes.NETWORK_ERROR,\n                    details: r,\n                    fatal: i,\n                    url: a.url,\n                    loader: a,\n                    response: e,\n                    context: t\n                  });\n                }\n              }, {\n                key: \"loadtimeout\",\n                value: function value(e, t) {\n                  var r,\n                      i,\n                      a = t.loader;\n\n                  switch (t.type) {\n                    case \"manifest\":\n                      r = v.ErrorDetails.MANIFEST_LOAD_TIMEOUT, i = !0;\n                      break;\n\n                    case \"level\":\n                      r = v.ErrorDetails.LEVEL_LOAD_TIMEOUT, i = !1;\n                      break;\n\n                    case \"audioTrack\":\n                      r = v.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT, i = !1;\n                  }\n\n                  a && (a.abort(), this.loaders[t.type] = void 0), this.hls.trigger(f.default.ERROR, {\n                    type: v.ErrorTypes.NETWORK_ERROR,\n                    details: r,\n                    fatal: i,\n                    url: a.url,\n                    loader: a,\n                    context: t\n                  });\n                }\n              }]), t;\n            }(c.default);\n\n            r.default = R;\n          }, {\n            2: 2,\n            26: 26,\n            27: 27,\n            28: 28,\n            40: 40,\n            45: 45\n          }],\n          37: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e() {\n                i(this, e);\n              }\n\n              return a(e, null, [{\n                key: \"init\",\n                value: function value() {\n                  e.types = {\n                    avc1: [],\n                    avcC: [],\n                    btrt: [],\n                    dinf: [],\n                    dref: [],\n                    esds: [],\n                    ftyp: [],\n                    hdlr: [],\n                    mdat: [],\n                    mdhd: [],\n                    mdia: [],\n                    mfhd: [],\n                    minf: [],\n                    moof: [],\n                    moov: [],\n                    mp4a: [],\n                    \".mp3\": [],\n                    mvex: [],\n                    mvhd: [],\n                    sdtp: [],\n                    stbl: [],\n                    stco: [],\n                    stsc: [],\n                    stsd: [],\n                    stsz: [],\n                    stts: [],\n                    tfdt: [],\n                    tfhd: [],\n                    traf: [],\n                    trak: [],\n                    trun: [],\n                    trex: [],\n                    tkhd: [],\n                    vmhd: [],\n                    smhd: []\n                  };\n                  var t;\n\n                  for (t in e.types) {\n                    e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);\n                  }\n\n                  var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),\n                      i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);\n                  e.HDLR_TYPES = {\n                    video: r,\n                    audio: i\n                  };\n                  var a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),\n                      n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);\n                  e.STTS = e.STSC = e.STCO = n, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);\n                  var s = new Uint8Array([105, 115, 111, 109]),\n                      o = new Uint8Array([97, 118, 99, 49]),\n                      l = new Uint8Array([0, 0, 0, 1]);\n                  e.FTYP = e.box(e.types.ftyp, s, l, s, o), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, a));\n                }\n              }, {\n                key: \"box\",\n                value: function value(e) {\n                  for (var t, r = Array.prototype.slice.call(arguments, 1), i = 8, a = r.length, n = a; a--;) {\n                    i += r[a].byteLength;\n                  }\n\n                  for (t = new Uint8Array(i), t[0] = i >> 24 & 255, t[1] = i >> 16 & 255, t[2] = i >> 8 & 255, t[3] = 255 & i, t.set(e, 4), a = 0, i = 8; n > a; a++) {\n                    t.set(r[a], i), i += r[a].byteLength;\n                  }\n\n                  return t;\n                }\n              }, {\n                key: \"hdlr\",\n                value: function value(t) {\n                  return e.box(e.types.hdlr, e.HDLR_TYPES[t]);\n                }\n              }, {\n                key: \"mdat\",\n                value: function value(t) {\n                  return e.box(e.types.mdat, t);\n                }\n              }, {\n                key: \"mdhd\",\n                value: function value(t, r) {\n                  return r *= t, e.box(e.types.mdhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0]));\n                }\n              }, {\n                key: \"mdia\",\n                value: function value(t) {\n                  return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t));\n                }\n              }, {\n                key: \"mfhd\",\n                value: function value(t) {\n                  return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]));\n                }\n              }, {\n                key: \"minf\",\n                value: function value(t) {\n                  return \"audio\" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t));\n                }\n              }, {\n                key: \"moof\",\n                value: function value(t, r, i) {\n                  return e.box(e.types.moof, e.mfhd(t), e.traf(i, r));\n                }\n              }, {\n                key: \"moov\",\n                value: function value(t) {\n                  for (var r = t.length, i = []; r--;) {\n                    i[r] = e.trak(t[r]);\n                  }\n\n                  return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(i).concat(e.mvex(t)));\n                }\n              }, {\n                key: \"mvex\",\n                value: function value(t) {\n                  for (var r = t.length, i = []; r--;) {\n                    i[r] = e.trex(t[r]);\n                  }\n\n                  return e.box.apply(null, [e.types.mvex].concat(i));\n                }\n              }, {\n                key: \"mvhd\",\n                value: function value(t, r) {\n                  r *= t;\n                  var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);\n                  return e.box(e.types.mvhd, i);\n                }\n              }, {\n                key: \"sdtp\",\n                value: function value(t) {\n                  var r,\n                      i,\n                      a = t.samples || [],\n                      n = new Uint8Array(4 + a.length);\n\n                  for (i = 0; a.length > i; i++) {\n                    r = a[i].flags, n[i + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy;\n                  }\n\n                  return e.box(e.types.sdtp, n);\n                }\n              }, {\n                key: \"stbl\",\n                value: function value(t) {\n                  return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO));\n                }\n              }, {\n                key: \"avc1\",\n                value: function value(t) {\n                  var r,\n                      i,\n                      a,\n                      n = [],\n                      s = [];\n\n                  for (r = 0; t.sps.length > r; r++) {\n                    i = t.sps[r], a = i.byteLength, n.push(a >>> 8 & 255), n.push(255 & a), n = n.concat(Array.prototype.slice.call(i));\n                  }\n\n                  for (r = 0; t.pps.length > r; r++) {\n                    i = t.pps[r], a = i.byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(i));\n                  }\n\n                  var o = e.box(e.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | t.sps.length].concat(n).concat([t.pps.length]).concat(s))),\n                      l = t.width,\n                      u = t.height;\n                  return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])));\n                }\n              }, {\n                key: \"esds\",\n                value: function value(e) {\n                  var t = e.config.length;\n                  return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]));\n                }\n              }, {\n                key: \"mp4a\",\n                value: function value(t) {\n                  var r = t.audiosamplerate;\n                  return e.box(e.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), e.box(e.types.esds, e.esds(t)));\n                }\n              }, {\n                key: \"mp3\",\n                value: function value(t) {\n                  var r = t.audiosamplerate;\n                  return e.box(e.types[\".mp3\"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]));\n                }\n              }, {\n                key: \"stsd\",\n                value: function value(t) {\n                  return \"audio\" === t.type ? t.isAAC || \"mp3\" !== t.codec ? e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.mp3(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t));\n                }\n              }, {\n                key: \"tkhd\",\n                value: function value(t) {\n                  var r = t.id,\n                      i = t.duration * t.timescale,\n                      a = t.width,\n                      n = t.height;\n                  return e.box(e.types.tkhd, new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, n >> 8 & 255, 255 & n, 0, 0]));\n                }\n              }, {\n                key: \"traf\",\n                value: function value(t, r) {\n                  var i = e.sdtp(t),\n                      a = t.id;\n                  return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), e.box(e.types.tfdt, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), e.trun(t, i.length + 16 + 16 + 8 + 16 + 8 + 8), i);\n                }\n              }, {\n                key: \"trak\",\n                value: function value(t) {\n                  return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t));\n                }\n              }, {\n                key: \"trex\",\n                value: function value(t) {\n                  var r = t.id;\n                  return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));\n                }\n              }, {\n                key: \"trun\",\n                value: function value(t, r) {\n                  var i,\n                      a,\n                      n,\n                      s,\n                      o,\n                      l,\n                      u = t.samples || [],\n                      d = u.length,\n                      f = 12 + 16 * d,\n                      h = new Uint8Array(f);\n\n                  for (r += 8 + f, h.set([0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; d > i; i++) {\n                    a = u[i], n = a.duration, s = a.size, o = a.flags, l = a.cts, h.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);\n                  }\n\n                  return e.box(e.types.trun, h);\n                }\n              }, {\n                key: \"initSegment\",\n                value: function value(t) {\n                  e.types || e.init();\n                  var r,\n                      i = e.moov(t);\n                  return r = new Uint8Array(e.FTYP.byteLength + i.byteLength), r.set(e.FTYP), r.set(i, e.FTYP.byteLength), r;\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          38: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(29),\n                o = i(s),\n                l = e(28),\n                u = i(l),\n                d = e(45),\n                f = e(37),\n                h = i(f),\n                c = e(26),\n                v = function () {\n              function e(t, r, i, n) {\n                a(this, e), this.observer = t, this.id = r, this.config = i, this.typeSupported = n, this.ISGenerated = !1, this.PES2MP4SCALEFACTOR = 4, this.PES_TIMESCALE = 9e4, this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;\n              }\n\n              return n(e, [{\n                key: \"destroy\",\n                value: function value() {}\n              }, {\n                key: \"insertDiscontinuity\",\n                value: function value() {\n                  this._initPTS = this._initDTS = void 0;\n                }\n              }, {\n                key: \"switchLevel\",\n                value: function value() {\n                  this.ISGenerated = !1;\n                }\n              }, {\n                key: \"remux\",\n                value: function value(e, t, r, i, a, n, s, o, l) {\n                  if (this.level = e, this.sn = t, this.ISGenerated || this.generateIS(r, i, s), this.ISGenerated) if (r.samples.length) {\n                    var d = this.remuxAudio(r, s, o, l);\n\n                    if (i.samples.length) {\n                      var f = void 0;\n                      d && (f = d.endPTS - d.startPTS), this.remuxVideo(i, s, o, f);\n                    }\n                  } else {\n                    var h = void 0;\n                    i.samples.length && (h = this.remuxVideo(i, s, o)), h && r.codec && this.remuxEmptyAudio(r, s, o, h);\n                  }\n                  a.samples.length && this.remuxID3(a, s), n.samples.length && this.remuxText(n, s), this.observer.trigger(u.default.FRAG_PARSED, {\n                    id: this.id,\n                    level: this.level,\n                    sn: this.sn\n                  });\n                }\n              }, {\n                key: \"generateIS\",\n                value: function value(e, t, r) {\n                  var i,\n                      a,\n                      n = this.observer,\n                      s = e.samples,\n                      o = t.samples,\n                      l = this.PES_TIMESCALE,\n                      f = this.typeSupported,\n                      v = \"audio/mp4\",\n                      g = {},\n                      p = {\n                    id: this.id,\n                    level: this.level,\n                    sn: this.sn,\n                    tracks: g,\n                    unique: !1\n                  },\n                      y = void 0 === this._initPTS;\n                  y && (i = a = 1 / 0), e.config && s.length && (e.timescale = e.audiosamplerate, e.timescale * e.duration > Math.pow(2, 32) && !function () {\n                    var t = function e(t, r) {\n                      return r ? e(r, t % r) : t;\n                    };\n\n                    e.timescale = e.audiosamplerate / t(e.audiosamplerate, e.isAAC ? 1024 : 1152);\n                  }(), d.logger.log(\"audio mp4 timescale :\" + e.timescale), e.isAAC || (f.mpeg ? (v = \"audio/mpeg\", e.codec = \"\") : f.mp3 && (e.codec = \"mp3\")), g.audio = {\n                    container: v,\n                    codec: e.codec,\n                    initSegment: !e.isAAC && f.mpeg ? new Uint8Array() : h.default.initSegment([e]),\n                    metadata: {\n                      channelCount: e.channelCount\n                    }\n                  }, y && (i = a = s[0].pts - l * r)), t.sps && t.pps && o.length && (t.timescale = this.MP4_TIMESCALE, g.video = {\n                    container: \"video/mp4\",\n                    codec: t.codec,\n                    initSegment: h.default.initSegment([t]),\n                    metadata: {\n                      width: t.width,\n                      height: t.height\n                    }\n                  }, y && (i = Math.min(i, o[0].pts - l * r), a = Math.min(a, o[0].dts - l * r))), Object.keys(g).length ? (n.trigger(u.default.FRAG_PARSING_INIT_SEGMENT, p), this.ISGenerated = !0, y && (this._initPTS = i, this._initDTS = a)) : n.trigger(u.default.ERROR, {\n                    type: c.ErrorTypes.MEDIA_ERROR,\n                    id: this.id,\n                    details: c.ErrorDetails.FRAG_PARSING_ERROR,\n                    fatal: !1,\n                    reason: \"no audio/video samples found\"\n                  });\n                }\n              }, {\n                key: \"remuxVideo\",\n                value: function value(e, t, r, i) {\n                  var a,\n                      n,\n                      s,\n                      o,\n                      l,\n                      f,\n                      v,\n                      g,\n                      p = 8,\n                      y = this.PES_TIMESCALE,\n                      m = this.PES2MP4SCALEFACTOR,\n                      E = e.samples,\n                      b = [],\n                      R = this._PTSNormalize,\n                      _ = this._initDTS;\n                  E.sort(function (e, t) {\n                    return e.dts - t.dts;\n                  });\n                  var k = E.reduce(function (e, t) {\n                    return Math.max(Math.min(e, t.pts - t.dts), -18e3);\n                  }, 0);\n\n                  if (0 > k) {\n                    d.logger.warn(\"PTS < DTS detected in video samples, shifting DTS by \" + Math.round(k / 90) + \" ms to overcome this issue\");\n\n                    for (var T = 0; E.length > T; T++) {\n                      E[T].dts += k;\n                    }\n                  }\n\n                  var A = void 0;\n                  A = r ? this.nextAvcDts : t * y;\n                  var S = E[0];\n                  l = Math.max(R(S.dts - _, A), 0), o = Math.max(R(S.pts - _, A), 0);\n                  var L = Math.round((l - A) / 90);\n                  r && L && (L > 1 ? d.logger.log(\"AVC:\" + L + \" ms hole between fragments detected,filling it\") : -1 > L && d.logger.log(\"AVC:\" + -L + \" ms overlapping between fragments detected\"), l = A, E[0].dts = l + _, o = Math.max(o - L, A), E[0].pts = o + _, d.logger.log(\"Video/PTS/DTS adjusted: \" + Math.round(o / 90) + \"/\" + Math.round(l / 90) + \",delta:\" + L + \" ms\")), f = l, S = E[E.length - 1], g = Math.max(R(S.dts - _, A), 0), v = Math.max(R(S.pts - _, A), 0), v = Math.max(v, g);\n                  var D = navigator.vendor,\n                      O = navigator.userAgent,\n                      w = D && D.indexOf(\"Apple\") > -1 && O && !O.match(\"CriOS\");\n                  w && (a = Math.round((g - l) / (m * (E.length - 1))));\n\n                  for (var P = 0; E.length > P; P++) {\n                    var C = E[P];\n                    w ? C.dts = l + P * m * a : (C.dts = Math.max(R(C.dts - _, A), l), C.dts = Math.round(C.dts / m) * m), C.pts = Math.max(R(C.pts - _, A), C.dts), C.pts = Math.round(C.pts / m) * m;\n                  }\n\n                  var I = e.len + 4 * e.nbNalu + 8;\n\n                  try {\n                    n = new Uint8Array(I);\n                  } catch (e) {\n                    return void this.observer.trigger(u.default.ERROR, {\n                      type: c.ErrorTypes.MUX_ERROR,\n                      level: this.level,\n                      id: this.id,\n                      details: c.ErrorDetails.REMUX_ALLOC_ERROR,\n                      fatal: !1,\n                      bytes: I,\n                      reason: \"fail allocating video mdat \" + I\n                    });\n                  }\n\n                  var M = new DataView(n.buffer);\n                  M.setUint32(0, n.byteLength), n.set(h.default.types.mdat, 4);\n\n                  for (var x = 0; E.length > x; x++) {\n                    for (var F = E[x], N = 0, U = void 0; F.units.units.length;) {\n                      var G = F.units.units.shift();\n                      M.setUint32(p, G.data.byteLength), p += 4, n.set(G.data, p), p += G.data.byteLength, N += 4 + G.data.byteLength;\n                    }\n\n                    if (w) U = Math.max(0, a * Math.round((F.pts - F.dts) / (m * a)));else {\n                      if (E.length - 1 > x) a = E[x + 1].dts - F.dts;else {\n                        var B = this.config,\n                            j = F.dts - E[x > 0 ? x - 1 : x].dts;\n\n                        if (B.stretchShortVideoTrack) {\n                          var H = B.maxBufferHole,\n                              K = B.maxSeekHole,\n                              V = Math.floor(Math.min(H, K) * y),\n                              W = (i ? o + i * y : this.nextAudioPts) - F.pts;\n                          W > V ? (a = W - j, 0 > a && (a = j), d.logger.log(\"It is approximately \" + W / 90 + \" ms to the next segment; using duration \" + a / 90 + \" ms for the last video frame.\")) : a = j;\n                        } else a = j;\n                      }\n                      a /= m, U = Math.round((F.pts - F.dts) / m);\n                    }\n                    b.push({\n                      size: N,\n                      duration: a,\n                      cts: U,\n                      flags: {\n                        isLeading: 0,\n                        isDependedOn: 0,\n                        hasRedundancy: 0,\n                        degradPrio: 0,\n                        dependsOn: F.key ? 2 : 1,\n                        isNonSync: F.key ? 0 : 1\n                      }\n                    });\n                  }\n\n                  this.nextAvcDts = g + a * m;\n                  var Y = e.dropped;\n\n                  if (e.len = 0, e.nbNalu = 0, e.dropped = 0, b.length && navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n                    var q = b[0].flags;\n                    q.dependsOn = 2, q.isNonSync = 0;\n                  }\n\n                  e.samples = b, s = h.default.moof(e.sequenceNumber++, l / m, e), e.samples = [];\n                  var X = {\n                    id: this.id,\n                    level: this.level,\n                    sn: this.sn,\n                    data1: s,\n                    data2: n,\n                    startPTS: o / y,\n                    endPTS: (v + m * a) / y,\n                    startDTS: l / y,\n                    endDTS: this.nextAvcDts / y,\n                    type: \"video\",\n                    nb: b.length,\n                    dropped: Y\n                  };\n                  return this.observer.trigger(u.default.FRAG_PARSING_DATA, X), X;\n                }\n              }, {\n                key: \"remuxAudio\",\n                value: function value(e, t, r, i) {\n                  var a,\n                      n,\n                      s,\n                      l,\n                      f,\n                      v,\n                      g,\n                      p,\n                      y,\n                      m,\n                      E,\n                      b,\n                      R,\n                      _,\n                      k,\n                      T,\n                      A = this.PES_TIMESCALE,\n                      S = e.timescale,\n                      L = A / S,\n                      D = e.timescale * (e.isAAC ? 1024 : 1152) / e.audiosamplerate,\n                      O = D * L,\n                      w = this._PTSNormalize,\n                      P = this._initDTS,\n                      C = !e.isAAC && this.typeSupported.mpeg,\n                      I = C ? 0 : 8,\n                      M = [],\n                      x = [];\n\n                  if (e.samples.sort(function (e, t) {\n                    return e.pts - t.pts;\n                  }), x = e.samples, T = this.nextAudioPts, r |= x.length && T && (Math.abs(t - T / A) < .1 || Math.abs(x[0].pts - T - this._initDTS) < 20 * O), r || (T = t * A), i && e.isAAC) for (var F = 0, N = T; x.length > F;) {\n                    var U = x[F],\n                        G = w(U.pts - P, T),\n                        B = G - N;\n                    if (-O < B) {\n                      if (B < O) Math.abs(B) > .1 * O, N += O, U.pts = U.dts = 0 === F ? P + T : x[F - 1].pts + O, F += 1;else {\n                        var j = Math.round(B / O);\n                        d.logger.warn(\"Injecting \" + j + \" audio frame @ \" + Math.round(N / 90) / 1e3 + \"s due to \" + Math.round(B / 90) + \" ms gap.\");\n\n                        for (var H = 0; j > H; H++) {\n                          k = N + P, k = Math.max(k, P), _ = o.default.getSilentFrame(e.channelCount), _ || (d.logger.log(\"Unable to get silent frame for given audio codec; duplicating last frame instead.\"), _ = U.unit.subarray()), x.splice(F, 0, {\n                            unit: _,\n                            pts: k,\n                            dts: k\n                          }), e.len += _.length, N += O, F += 1;\n                        }\n\n                        U.pts = U.dts = N + P, N += O, F += 1;\n                      }\n                    } else d.logger.warn(\"Dropping 1 audio frame @ \" + Math.round(N / 90) / 1e3 + \"s due to \" + Math.round(Math.abs(B / 90)) + \" ms overlap.\"), x.splice(F, 1), e.len -= U.unit.length;\n                  }\n\n                  for (; x.length;) {\n                    if (n = x.shift(), l = n.unit, m = n.pts - P, E = n.dts - P, void 0 !== y) b = w(m, y), R = w(E, y), s.duration = Math.round((R - y) / L);else {\n                      b = w(m, T), R = w(E, T);\n                      var K = Math.round(1e3 * (b - T) / A),\n                          V = 0;\n\n                      if (r && e.isAAC && K) {\n                        if (K > 0) V = Math.round((b - T) / O), d.logger.log(K + \" ms hole between AAC samples detected,filling it\"), V > 0 && (_ = o.default.getSilentFrame(e.channelCount), _ || (_ = l.subarray()), e.len += V * _.length);else if (-12 > K) {\n                          d.logger.log(-K + \" ms overlapping between AAC samples detected, drop frame\"), e.len -= l.byteLength;\n                          continue;\n                        }\n                        b = R = T;\n                      }\n\n                      if (g = Math.max(0, b), p = Math.max(0, R), 0 >= e.len) return;\n                      var W = C ? e.len : e.len + 8;\n\n                      try {\n                        f = new Uint8Array(W);\n                      } catch (e) {\n                        return void this.observer.trigger(u.default.ERROR, {\n                          type: c.ErrorTypes.MUX_ERROR,\n                          level: this.level,\n                          id: this.id,\n                          details: c.ErrorDetails.REMUX_ALLOC_ERROR,\n                          fatal: !1,\n                          bytes: W,\n                          reason: \"fail allocating audio mdat \" + W\n                        });\n                      }\n\n                      C || (a = new DataView(f.buffer), a.setUint32(0, f.byteLength), f.set(h.default.types.mdat, 4));\n\n                      for (var Y = 0; V > Y; Y++) {\n                        k = b - (V - Y) * O, _ = o.default.getSilentFrame(e.channelCount), _ || (d.logger.log(\"Unable to get silent frame for given audio codec; duplicating this frame instead.\"), _ = l.subarray()), f.set(_, I), I += _.byteLength, s = {\n                          size: _.byteLength,\n                          cts: 0,\n                          duration: 1024,\n                          flags: {\n                            isLeading: 0,\n                            isDependedOn: 0,\n                            hasRedundancy: 0,\n                            degradPrio: 0,\n                            dependsOn: 1\n                          }\n                        }, M.push(s);\n                      }\n                    }\n                    f.set(l, I), I += l.byteLength, s = {\n                      size: l.byteLength,\n                      cts: 0,\n                      duration: 0,\n                      flags: {\n                        isLeading: 0,\n                        isDependedOn: 0,\n                        hasRedundancy: 0,\n                        degradPrio: 0,\n                        dependsOn: 1\n                      }\n                    }, M.push(s), y = R;\n                  }\n\n                  var q = 0,\n                      X = M.length;\n\n                  if (2 > X || (q = M[X - 2].duration, s.duration = q), X) {\n                    this.nextAudioPts = b + L * q, e.len = 0, e.samples = M, v = C ? new Uint8Array() : h.default.moof(e.sequenceNumber++, p / L, e), e.samples = [];\n                    var z = {\n                      id: this.id,\n                      level: this.level,\n                      sn: this.sn,\n                      data1: v,\n                      data2: f,\n                      startPTS: g / A,\n                      endPTS: this.nextAudioPts / A,\n                      startDTS: p / A,\n                      endDTS: (R + L * q) / A,\n                      type: \"audio\",\n                      nb: X\n                    };\n                    return this.observer.trigger(u.default.FRAG_PARSING_DATA, z), z;\n                  }\n\n                  return null;\n                }\n              }, {\n                key: \"remuxEmptyAudio\",\n                value: function value(e, t, r, i) {\n                  var a = this.PES_TIMESCALE,\n                      n = e.timescale ? e.timescale : e.audiosamplerate,\n                      s = a / n,\n                      l = this.nextAudioPts,\n                      u = (void 0 !== l ? l : i.startDTS * a) + this._initDTS,\n                      f = i.endDTS * a + this._initDTS,\n                      h = 1024,\n                      c = s * h,\n                      v = Math.ceil((f - u) / c),\n                      g = o.default.getSilentFrame(e.channelCount);\n                  if (d.logger.warn(\"remux empty Audio\"), !g) return void d.logger.trace(\"Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!\");\n\n                  for (var p = [], y = 0; v > y; y++) {\n                    var m = u + y * c;\n                    p.push({\n                      unit: g,\n                      pts: m,\n                      dts: m\n                    }), e.len += g.length;\n                  }\n\n                  e.samples = p, this.remuxAudio(e, t, r);\n                }\n              }, {\n                key: \"remuxID3\",\n                value: function value(e, t) {\n                  var r,\n                      i = e.samples.length;\n\n                  if (i) {\n                    for (var a = 0; i > a; a++) {\n                      r = e.samples[a], r.pts = (r.pts - this._initPTS) / this.PES_TIMESCALE, r.dts = (r.dts - this._initDTS) / this.PES_TIMESCALE;\n                    }\n\n                    this.observer.trigger(u.default.FRAG_PARSING_METADATA, {\n                      id: this.id,\n                      level: this.level,\n                      sn: this.sn,\n                      samples: e.samples\n                    });\n                  }\n\n                  e.samples = [], t = t;\n                }\n              }, {\n                key: \"remuxText\",\n                value: function value(e, t) {\n                  e.samples.sort(function (e, t) {\n                    return e.pts - t.pts;\n                  });\n                  var r,\n                      i = e.samples.length;\n\n                  if (i) {\n                    for (var a = 0; i > a; a++) {\n                      r = e.samples[a], r.pts = (r.pts - this._initPTS) / this.PES_TIMESCALE;\n                    }\n\n                    this.observer.trigger(u.default.FRAG_PARSING_USERDATA, {\n                      id: this.id,\n                      level: this.level,\n                      sn: this.sn,\n                      samples: e.samples\n                    });\n                  }\n\n                  e.samples = [], t = t;\n                }\n              }, {\n                key: \"_PTSNormalize\",\n                value: function value(e, t) {\n                  var r;\n                  if (void 0 === t) return e;\n\n                  for (r = e > t ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) {\n                    e += r;\n                  }\n\n                  return e;\n                }\n              }, {\n                key: \"passthrough\",\n                get: function get() {\n                  return !1;\n                }\n              }]), e;\n            }();\n\n            r.default = v;\n          }, {\n            26: 26,\n            28: 28,\n            29: 29,\n            37: 37,\n            45: 45\n          }],\n          39: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e) {\n              return e && e.__esModule ? e : {\n                default: e\n              };\n            }\n\n            function a(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var n = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                s = e(28),\n                o = i(s),\n                l = function () {\n              function e(t, r) {\n                a(this, e), this.observer = t, this.id = r, this.ISGenerated = !1;\n              }\n\n              return n(e, [{\n                key: \"destroy\",\n                value: function value() {}\n              }, {\n                key: \"insertDiscontinuity\",\n                value: function value() {}\n              }, {\n                key: \"switchLevel\",\n                value: function value() {\n                  this.ISGenerated = !1;\n                }\n              }, {\n                key: \"remux\",\n                value: function value(e, t, r, i, a, n) {\n                  var s = this.observer;\n\n                  if (!this.ISGenerated) {\n                    var l = {},\n                        u = {\n                      id: this.id,\n                      tracks: l,\n                      unique: !0\n                    },\n                        d = t,\n                        f = d.codec;\n                    f && (u.tracks.video = {\n                      container: d.container,\n                      codec: f,\n                      metadata: {\n                        width: d.width,\n                        height: d.height\n                      }\n                    }), d = e, f = d.codec, f && (u.tracks.audio = {\n                      container: d.container,\n                      codec: f,\n                      metadata: {\n                        channelCount: d.channelCount\n                      }\n                    }), this.ISGenerated = !0, s.trigger(o.default.FRAG_PARSING_INIT_SEGMENT, u);\n                  }\n\n                  s.trigger(o.default.FRAG_PARSING_DATA, {\n                    id: this.id,\n                    data1: n,\n                    startPTS: a,\n                    startDTS: a,\n                    type: \"audiovideo\",\n                    nb: 1,\n                    dropped: 0\n                  });\n                }\n              }, {\n                key: \"passthrough\",\n                get: function get() {\n                  return !0;\n                }\n              }]), e;\n            }();\n\n            r.default = l;\n          }, {\n            28: 28\n          }],\n          40: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = /^(\\d+)x(\\d+)$/,\n                s = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g,\n                o = function () {\n              function e(t) {\n                i(this, e), \"string\" == typeof t && (t = e.parseAttrList(t));\n\n                for (var r in t) {\n                  t.hasOwnProperty(r) && (this[r] = t[r]);\n                }\n              }\n\n              return a(e, [{\n                key: \"decimalInteger\",\n                value: function value(e) {\n                  var t = parseInt(this[e], 10);\n                  return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n                }\n              }, {\n                key: \"hexadecimalInteger\",\n                value: function value(e) {\n                  if (this[e]) {\n                    var t = (this[e] || \"0x\").slice(2);\n                    t = (1 & t.length ? \"0\" : \"\") + t;\n\n                    for (var r = new Uint8Array(t.length / 2), i = 0; t.length / 2 > i; i++) {\n                      r[i] = parseInt(t.slice(2 * i, 2 * i + 2), 16);\n                    }\n\n                    return r;\n                  }\n\n                  return null;\n                }\n              }, {\n                key: \"hexadecimalIntegerAsNumber\",\n                value: function value(e) {\n                  var t = parseInt(this[e], 16);\n                  return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n                }\n              }, {\n                key: \"decimalFloatingPoint\",\n                value: function value(e) {\n                  return parseFloat(this[e]);\n                }\n              }, {\n                key: \"enumeratedString\",\n                value: function value(e) {\n                  return this[e];\n                }\n              }, {\n                key: \"decimalResolution\",\n                value: function value(e) {\n                  var t = n.exec(this[e]);\n                  if (null !== t) return {\n                    width: parseInt(t[1], 10),\n                    height: parseInt(t[2], 10)\n                  };\n                }\n              }], [{\n                key: \"parseAttrList\",\n                value: function value(e) {\n                  var t,\n                      r = {};\n\n                  for (s.lastIndex = 0; null !== (t = s.exec(e));) {\n                    var i = t[2],\n                        a = '\"';\n                    0 === i.indexOf(a) && i.lastIndexOf(a) === i.length - 1 && (i = i.slice(1, -1)), r[t[1]] = i;\n                  }\n\n                  return r;\n                }\n              }]), e;\n            }();\n\n            r.default = o;\n          }, {}],\n          41: [function (e, t, r) {\n            \"use strict\";\n\n            var i = {\n              search: function search(e, t) {\n                for (var r = 0, i = e.length - 1, a = null, n = null; i >= r;) {\n                  a = (r + i) / 2 | 0, n = e[a];\n                  var s = t(n);\n                  if (s > 0) r = a + 1;else {\n                    if (s >= 0) return n;\n                    i = a - 1;\n                  }\n                }\n\n                return null;\n              }\n            };\n            t.exports = i;\n          }, {}],\n          42: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = {\n              42: 225,\n              92: 233,\n              94: 237,\n              95: 243,\n              96: 250,\n              123: 231,\n              124: 247,\n              125: 209,\n              126: 241,\n              127: 9608,\n              128: 174,\n              129: 176,\n              130: 189,\n              131: 191,\n              132: 8482,\n              133: 162,\n              134: 163,\n              135: 9834,\n              136: 224,\n              137: 32,\n              138: 232,\n              139: 226,\n              140: 234,\n              141: 238,\n              142: 244,\n              143: 251,\n              144: 193,\n              145: 201,\n              146: 211,\n              147: 218,\n              148: 220,\n              149: 252,\n              150: 8216,\n              151: 161,\n              152: 42,\n              153: 8217,\n              154: 9473,\n              155: 169,\n              156: 8480,\n              157: 8226,\n              158: 8220,\n              159: 8221,\n              160: 192,\n              161: 194,\n              162: 199,\n              163: 200,\n              164: 202,\n              165: 203,\n              166: 235,\n              167: 206,\n              168: 207,\n              169: 239,\n              170: 212,\n              171: 217,\n              172: 249,\n              173: 219,\n              174: 171,\n              175: 187,\n              176: 195,\n              177: 227,\n              178: 205,\n              179: 204,\n              180: 236,\n              181: 210,\n              182: 242,\n              183: 213,\n              184: 245,\n              185: 123,\n              186: 125,\n              187: 92,\n              188: 94,\n              189: 95,\n              190: 124,\n              191: 8764,\n              192: 196,\n              193: 228,\n              194: 214,\n              195: 246,\n              196: 223,\n              197: 165,\n              198: 164,\n              199: 9475,\n              200: 197,\n              201: 229,\n              202: 216,\n              203: 248,\n              204: 9487,\n              205: 9491,\n              206: 9495,\n              207: 9499\n            },\n                s = function s(e) {\n              var t = e;\n              return n.hasOwnProperty(e) && (t = n[e]), String.fromCharCode(t);\n            },\n                o = 15,\n                l = 32,\n                u = {\n              17: 1,\n              18: 3,\n              21: 5,\n              22: 7,\n              23: 9,\n              16: 11,\n              19: 12,\n              20: 14\n            },\n                d = {\n              17: 2,\n              18: 4,\n              21: 6,\n              22: 8,\n              23: 10,\n              19: 13,\n              20: 15\n            },\n                f = {\n              25: 1,\n              26: 3,\n              29: 5,\n              30: 7,\n              31: 9,\n              24: 11,\n              27: 12,\n              28: 14\n            },\n                h = {\n              25: 2,\n              26: 4,\n              29: 6,\n              30: 8,\n              31: 10,\n              27: 13,\n              28: 15\n            },\n                c = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\", \"black\", \"transparent\"],\n                v = {\n              verboseFilter: {\n                DATA: 3,\n                DEBUG: 3,\n                INFO: 2,\n                WARNING: 2,\n                TEXT: 1,\n                ERROR: 0\n              },\n              time: null,\n              verboseLevel: 0,\n              setTime: function setTime(e) {\n                this.time = e;\n              },\n              log: function log(e, t) {\n                var r = this.verboseFilter[e];\n                r > this.verboseLevel || console.log(this.time + \" [\" + e + \"] \" + t);\n              }\n            },\n                g = function g(e) {\n              for (var t = [], r = 0; e.length > r; r++) {\n                t.push(e[r].toString(16));\n              }\n\n              return t;\n            },\n                p = function () {\n              function e(t, r, a, n, s) {\n                i(this, e), this.foreground = t || \"white\", this.underline = r || !1, this.italics = a || !1, this.background = n || \"black\", this.flash = s || !1;\n              }\n\n              return a(e, [{\n                key: \"reset\",\n                value: function value() {\n                  this.foreground = \"white\", this.underline = !1, this.italics = !1, this.background = \"black\", this.flash = !1;\n                }\n              }, {\n                key: \"setStyles\",\n                value: function value(e) {\n                  for (var t = [\"foreground\", \"underline\", \"italics\", \"background\", \"flash\"], r = 0; t.length > r; r++) {\n                    var i = t[r];\n                    e.hasOwnProperty(i) && (this[i] = e[i]);\n                  }\n                }\n              }, {\n                key: \"isDefault\",\n                value: function value() {\n                  return \"white\" === this.foreground && !this.underline && !this.italics && \"black\" === this.background && !this.flash;\n                }\n              }, {\n                key: \"equals\",\n                value: function value(e) {\n                  return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;\n                }\n              }, {\n                key: \"copy\",\n                value: function value(e) {\n                  this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;\n                }\n              }, {\n                key: \"toString\",\n                value: function value() {\n                  return \"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics + \", background=\" + this.background + \", flash=\" + this.flash;\n                }\n              }]), e;\n            }(),\n                y = function () {\n              function e(t, r, a, n, s, o) {\n                i(this, e), this.uchar = t || \" \", this.penState = new p(r, a, n, s, o);\n              }\n\n              return a(e, [{\n                key: \"reset\",\n                value: function value() {\n                  this.uchar = \" \", this.penState.reset();\n                }\n              }, {\n                key: \"setChar\",\n                value: function value(e, t) {\n                  this.uchar = e, this.penState.copy(t);\n                }\n              }, {\n                key: \"setPenState\",\n                value: function value(e) {\n                  this.penState.copy(e);\n                }\n              }, {\n                key: \"equals\",\n                value: function value(e) {\n                  return this.uchar === e.uchar && this.penState.equals(e.penState);\n                }\n              }, {\n                key: \"copy\",\n                value: function value(e) {\n                  this.uchar = e.uchar, this.penState.copy(e.penState);\n                }\n              }, {\n                key: \"isEmpty\",\n                value: function value() {\n                  return \" \" === this.uchar && this.penState.isDefault();\n                }\n              }]), e;\n            }(),\n                m = function () {\n              function e() {\n                i(this, e), this.chars = [];\n\n                for (var t = 0; l > t; t++) {\n                  this.chars.push(new y());\n                }\n\n                this.pos = 0, this.currPenState = new p();\n              }\n\n              return a(e, [{\n                key: \"equals\",\n                value: function value(e) {\n                  for (var t = !0, r = 0; l > r; r++) {\n                    if (!this.chars[r].equals(e.chars[r])) {\n                      t = !1;\n                      break;\n                    }\n                  }\n\n                  return t;\n                }\n              }, {\n                key: \"copy\",\n                value: function value(e) {\n                  for (var t = 0; l > t; t++) {\n                    this.chars[t].copy(e.chars[t]);\n                  }\n                }\n              }, {\n                key: \"isEmpty\",\n                value: function value() {\n                  for (var e = !0, t = 0; l > t; t++) {\n                    if (!this.chars[t].isEmpty()) {\n                      e = !1;\n                      break;\n                    }\n                  }\n\n                  return e;\n                }\n              }, {\n                key: \"setCursor\",\n                value: function value(e) {\n                  this.pos !== e && (this.pos = e), 0 > this.pos ? (v.log(\"ERROR\", \"Negative cursor position \" + this.pos), this.pos = 0) : this.pos > l && (v.log(\"ERROR\", \"Too large cursor position \" + this.pos), this.pos = l);\n                }\n              }, {\n                key: \"moveCursor\",\n                value: function value(e) {\n                  var t = this.pos + e;\n                  if (e > 1) for (var r = this.pos + 1; t + 1 > r; r++) {\n                    this.chars[r].setPenState(this.currPenState);\n                  }\n                  this.setCursor(t);\n                }\n              }, {\n                key: \"backSpace\",\n                value: function value() {\n                  this.moveCursor(-1), this.chars[this.pos].setChar(\" \", this.currPenState);\n                }\n              }, {\n                key: \"insertChar\",\n                value: function value(e) {\n                  144 > e || this.backSpace();\n                  var t = s(e);\n                  return l > this.pos ? (this.chars[this.pos].setChar(t, this.currPenState), void this.moveCursor(1)) : void v.log(\"ERROR\", \"Cannot insert \" + e.toString(16) + \" (\" + t + \") at position \" + this.pos + \". Skipping it!\");\n                }\n              }, {\n                key: \"clearFromPos\",\n                value: function value(e) {\n                  var t;\n\n                  for (t = e; l > t; t++) {\n                    this.chars[t].reset();\n                  }\n                }\n              }, {\n                key: \"clear\",\n                value: function value() {\n                  this.clearFromPos(0), this.pos = 0, this.currPenState.reset();\n                }\n              }, {\n                key: \"clearToEndOfRow\",\n                value: function value() {\n                  this.clearFromPos(this.pos);\n                }\n              }, {\n                key: \"getTextString\",\n                value: function value() {\n                  for (var e = [], t = !0, r = 0; l > r; r++) {\n                    var i = this.chars[r].uchar;\n                    \" \" !== i && (t = !1), e.push(i);\n                  }\n\n                  return t ? \"\" : e.join(\"\");\n                }\n              }, {\n                key: \"setPenStyles\",\n                value: function value(e) {\n                  this.currPenState.setStyles(e);\n                  var t = this.chars[this.pos];\n                  t.setPenState(this.currPenState);\n                }\n              }]), e;\n            }(),\n                E = function () {\n              function e() {\n                i(this, e), this.rows = [];\n\n                for (var t = 0; o > t; t++) {\n                  this.rows.push(new m());\n                }\n\n                this.currRow = o - 1, this.nrRollUpRows = null, this.reset();\n              }\n\n              return a(e, [{\n                key: \"reset\",\n                value: function value() {\n                  for (var e = 0; o > e; e++) {\n                    this.rows[e].clear();\n                  }\n\n                  this.currRow = o - 1;\n                }\n              }, {\n                key: \"equals\",\n                value: function value(e) {\n                  for (var t = !0, r = 0; o > r; r++) {\n                    if (!this.rows[r].equals(e.rows[r])) {\n                      t = !1;\n                      break;\n                    }\n                  }\n\n                  return t;\n                }\n              }, {\n                key: \"copy\",\n                value: function value(e) {\n                  for (var t = 0; o > t; t++) {\n                    this.rows[t].copy(e.rows[t]);\n                  }\n                }\n              }, {\n                key: \"isEmpty\",\n                value: function value() {\n                  for (var e = !0, t = 0; o > t; t++) {\n                    if (!this.rows[t].isEmpty()) {\n                      e = !1;\n                      break;\n                    }\n                  }\n\n                  return e;\n                }\n              }, {\n                key: \"backSpace\",\n                value: function value() {\n                  var e = this.rows[this.currRow];\n                  e.backSpace();\n                }\n              }, {\n                key: \"clearToEndOfRow\",\n                value: function value() {\n                  var e = this.rows[this.currRow];\n                  e.clearToEndOfRow();\n                }\n              }, {\n                key: \"insertChar\",\n                value: function value(e) {\n                  var t = this.rows[this.currRow];\n                  t.insertChar(e);\n                }\n              }, {\n                key: \"setPen\",\n                value: function value(e) {\n                  var t = this.rows[this.currRow];\n                  t.setPenStyles(e);\n                }\n              }, {\n                key: \"moveCursor\",\n                value: function value(e) {\n                  var t = this.rows[this.currRow];\n                  t.moveCursor(e);\n                }\n              }, {\n                key: \"setCursor\",\n                value: function value(e) {\n                  v.log(\"INFO\", \"setCursor: \" + e);\n                  var t = this.rows[this.currRow];\n                  t.setCursor(e);\n                }\n              }, {\n                key: \"setPAC\",\n                value: function value(e, t) {\n                  v.log(\"INFO\", \"pacData = \" + JSON.stringify(e));\n                  var r = e.row - 1;\n\n                  if (this.nrRollUpRows && this.nrRollUpRows - 1 > r && (r = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== r) {\n                    for (var i = 0; o > i; i++) {\n                      this.rows[i].clear();\n                    }\n\n                    var a = this.currRow + 1 - this.nrRollUpRows,\n                        n = t.rows[a].cueStartTime;\n                    if (n && v.time > n) for (i = 0; this.nrRollUpRows > i; i++) {\n                      this.rows[r - this.nrRollUpRows + i + 1].copy(t.rows[a + i]);\n                    }\n                  }\n\n                  this.currRow = r;\n                  var s = this.rows[this.currRow];\n\n                  if (null !== e.indent) {\n                    var l = e.indent,\n                        u = Math.max(l - 1, 0);\n                    s.setCursor(e.indent), e.color = s.chars[u].penState.foreground;\n                  }\n\n                  var d = {\n                    foreground: e.color,\n                    underline: e.underline,\n                    italics: e.italics,\n                    background: \"black\",\n                    flash: !1\n                  };\n                  this.setPen(d);\n                }\n              }, {\n                key: \"setBkgData\",\n                value: function value(e) {\n                  v.log(\"INFO\", \"bkgData = \" + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32);\n                }\n              }, {\n                key: \"setRollUpRows\",\n                value: function value(e) {\n                  this.nrRollUpRows = e;\n                }\n              }, {\n                key: \"rollUp\",\n                value: function value() {\n                  if (null === this.nrRollUpRows) return void v.log(\"DEBUG\", \"roll_up but nrRollUpRows not set yet\");\n                  v.log(\"TEXT\", this.getDisplayText());\n                  var e = this.currRow + 1 - this.nrRollUpRows,\n                      t = this.rows.splice(e, 1)[0];\n                  t.clear(), this.rows.splice(this.currRow, 0, t), v.log(\"INFO\", \"Rolling up\");\n                }\n              }, {\n                key: \"getDisplayText\",\n                value: function value(e) {\n                  e = e || !1;\n\n                  for (var t = [], r = \"\", i = -1, a = 0; o > a; a++) {\n                    var n = this.rows[a].getTextString();\n                    n && (i = a + 1, t.push(e ? \"Row \" + i + \": '\" + n + \"'\" : n.trim()));\n                  }\n\n                  return t.length > 0 && (r = e ? \"[\" + t.join(\" | \") + \"]\" : t.join(\"\\n\")), r;\n                }\n              }, {\n                key: \"getTextAndFormat\",\n                value: function value() {\n                  return this.rows;\n                }\n              }]), e;\n            }(),\n                b = function () {\n              function e(t, r) {\n                i(this, e), this.chNr = t, this.outputFilter = r, this.mode = null, this.verbose = 0, this.displayedMemory = new E(), this.nonDisplayedMemory = new E(), this.lastOutputScreen = new E(), this.currRollUpRow = this.displayedMemory.rows[o - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;\n              }\n\n              return a(e, [{\n                key: \"reset\",\n                value: function value() {\n                  this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[o - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null;\n                }\n              }, {\n                key: \"getHandler\",\n                value: function value() {\n                  return this.outputFilter;\n                }\n              }, {\n                key: \"setHandler\",\n                value: function value(e) {\n                  this.outputFilter = e;\n                }\n              }, {\n                key: \"setPAC\",\n                value: function value(e) {\n                  this.writeScreen.setPAC(e, this.lastOutputScreen);\n                }\n              }, {\n                key: \"setBkgData\",\n                value: function value(e) {\n                  this.writeScreen.setBkgData(e);\n                }\n              }, {\n                key: \"setMode\",\n                value: function value(e) {\n                  e !== this.mode && (this.mode = e, v.log(\"INFO\", \"MODE=\" + e), \"MODE_POP-ON\" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset(), this.lastOutputScreen.reset()), \"MODE_ROLL-UP\" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);\n                }\n              }, {\n                key: \"insertChars\",\n                value: function value(e) {\n                  for (var t = 0; e.length > t; t++) {\n                    this.writeScreen.insertChar(e[t]);\n                  }\n\n                  var r = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n                  v.log(\"INFO\", r + \": \" + this.writeScreen.getDisplayText(!0)), \"MODE_PAINT-ON\" !== this.mode && \"MODE_ROLL-UP\" !== this.mode || (v.log(\"TEXT\", \"DISPLAYED: \" + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());\n                }\n              }, {\n                key: \"ccRCL\",\n                value: function value() {\n                  v.log(\"INFO\", \"RCL - Resume Caption Loading\"), this.setMode(\"MODE_POP-ON\");\n                }\n              }, {\n                key: \"ccBS\",\n                value: function value() {\n                  v.log(\"INFO\", \"BS - BackSpace\"), \"MODE_TEXT\" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());\n                }\n              }, {\n                key: \"ccAOF\",\n                value: function value() {}\n              }, {\n                key: \"ccAON\",\n                value: function value() {}\n              }, {\n                key: \"ccDER\",\n                value: function value() {\n                  v.log(\"INFO\", \"DER- Delete to End of Row\"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();\n                }\n              }, {\n                key: \"ccRU\",\n                value: function value(e) {\n                  v.log(\"INFO\", \"RU(\" + e + \") - Roll Up\"), this.writeScreen = this.displayedMemory, this.setMode(\"MODE_ROLL-UP\"), this.writeScreen.setRollUpRows(e);\n                }\n              }, {\n                key: \"ccFON\",\n                value: function value() {\n                  v.log(\"INFO\", \"FON - Flash On\"), this.writeScreen.setPen({\n                    flash: !0\n                  });\n                }\n              }, {\n                key: \"ccRDC\",\n                value: function value() {\n                  v.log(\"INFO\", \"RDC - Resume Direct Captioning\"), this.setMode(\"MODE_PAINT-ON\");\n                }\n              }, {\n                key: \"ccTR\",\n                value: function value() {\n                  v.log(\"INFO\", \"TR\"), this.setMode(\"MODE_TEXT\");\n                }\n              }, {\n                key: \"ccRTD\",\n                value: function value() {\n                  v.log(\"INFO\", \"RTD\"), this.setMode(\"MODE_TEXT\");\n                }\n              }, {\n                key: \"ccEDM\",\n                value: function value() {\n                  v.log(\"INFO\", \"EDM - Erase Displayed Memory\"), this.displayedMemory.reset(), this.outputDataUpdate();\n                }\n              }, {\n                key: \"ccCR\",\n                value: function value() {\n                  v.log(\"CR - Carriage Return\"), this.writeScreen.rollUp(), this.outputDataUpdate();\n                }\n              }, {\n                key: \"ccENM\",\n                value: function value() {\n                  v.log(\"INFO\", \"ENM - Erase Non-displayed Memory\"), this.nonDisplayedMemory.reset();\n                }\n              }, {\n                key: \"ccEOC\",\n                value: function value() {\n                  if (v.log(\"INFO\", \"EOC - End Of Caption\"), \"MODE_POP-ON\" === this.mode) {\n                    var e = this.displayedMemory;\n                    this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, v.log(\"TEXT\", \"DISP: \" + this.displayedMemory.getDisplayText());\n                  }\n\n                  this.outputDataUpdate();\n                }\n              }, {\n                key: \"ccTO\",\n                value: function value(e) {\n                  v.log(\"INFO\", \"TO(\" + e + \") - Tab Offset\"), this.writeScreen.moveCursor(e);\n                }\n              }, {\n                key: \"ccMIDROW\",\n                value: function value(e) {\n                  var t = {\n                    flash: !1\n                  };\n                  if (t.underline = e % 2 === 1, t.italics = e >= 46) t.foreground = \"white\";else {\n                    var r = Math.floor(e / 2) - 16,\n                        i = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\"];\n                    t.foreground = i[r];\n                  }\n                  v.log(\"INFO\", \"MIDROW: \" + JSON.stringify(t)), this.writeScreen.setPen(t);\n                }\n              }, {\n                key: \"outputDataUpdate\",\n                value: function value() {\n                  var e = v.time;\n                  null !== e && this.outputFilter && (this.outputFilter.updateData && this.outputFilter.updateData(e, this.displayedMemory), null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.lastOutputScreen), this.cueStartTime = this.displayedMemory.isEmpty() ? null : e) : this.cueStartTime = e, this.lastOutputScreen.copy(this.displayedMemory));\n                }\n              }, {\n                key: \"cueSplitAtTime\",\n                value: function value(e) {\n                  this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));\n                }\n              }]), e;\n            }(),\n                R = function () {\n              function e(t, r, a) {\n                i(this, e), this.field = t || 1, this.outputs = [r, a], this.channels = [new b(1, r), new b(2, a)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.bufferedData = [], this.startTime = null, this.lastTime = null, this.dataCounters = {\n                  padding: 0,\n                  char: 0,\n                  cmd: 0,\n                  other: 0\n                };\n              }\n\n              return a(e, [{\n                key: \"getHandler\",\n                value: function value(e) {\n                  return this.channels[e].getHandler();\n                }\n              }, {\n                key: \"setHandler\",\n                value: function value(e, t) {\n                  this.channels[e].setHandler(t);\n                }\n              }, {\n                key: \"addData\",\n                value: function value(e, t) {\n                  var r,\n                      i,\n                      a,\n                      n = !1;\n                  this.lastTime = e, v.setTime(e);\n\n                  for (var s = 0; t.length > s; s += 2) {\n                    if (i = 127 & t[s], a = 127 & t[s + 1], 0 !== i || 0 !== a) {\n                      if (v.log(\"DATA\", \"[\" + g([t[s], t[s + 1]]) + \"] -> (\" + g([i, a]) + \")\"), r = this.parseCmd(i, a), r || (r = this.parseMidrow(i, a)), r || (r = this.parsePAC(i, a)), r || (r = this.parseBackgroundAttributes(i, a)), !r && (n = this.parseChars(i, a))) if (this.currChNr && this.currChNr >= 0) {\n                        var o = this.channels[this.currChNr - 1];\n                        o.insertChars(n);\n                      } else v.log(\"WARNING\", \"No channel found yet. TEXT-MODE?\");\n                      r ? this.dataCounters.cmd += 2 : n ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, v.log(\"WARNING\", \"Couldn't parse cleaned data \" + g([i, a]) + \" orig: \" + g([t[s], t[s + 1]])));\n                    } else this.dataCounters.padding += 2;\n                  }\n                }\n              }, {\n                key: \"parseCmd\",\n                value: function value(e, t) {\n                  var r = null,\n                      i = !(20 !== e && 28 !== e || 32 > t || t > 47),\n                      a = !(23 !== e && 31 !== e || 33 > t || t > 35);\n                  if (!i && !a) return !1;\n                  if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, this.lastCmdB = null, v.log(\"DEBUG\", \"Repeated command (\" + g([e, t]) + \") is dropped\"), !0;\n                  r = 20 === e || 23 === e ? 1 : 2;\n                  var n = this.channels[r - 1];\n                  return 20 === e || 28 === e ? 32 === t ? n.ccRCL() : 33 === t ? n.ccBS() : 34 === t ? n.ccAOF() : 35 === t ? n.ccAON() : 36 === t ? n.ccDER() : 37 === t ? n.ccRU(2) : 38 === t ? n.ccRU(3) : 39 === t ? n.ccRU(4) : 40 === t ? n.ccFON() : 41 === t ? n.ccRDC() : 42 === t ? n.ccTR() : 43 === t ? n.ccRTD() : 44 === t ? n.ccEDM() : 45 === t ? n.ccCR() : 46 === t ? n.ccENM() : 47 === t && n.ccEOC() : n.ccTO(t - 32), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0;\n                }\n              }, {\n                key: \"parseMidrow\",\n                value: function value(e, t) {\n                  var r = null;\n\n                  if (!(17 !== e && 25 !== e || 32 > t || t > 47)) {\n                    if (r = 17 === e ? 1 : 2, r !== this.currChNr) return v.log(\"ERROR\", \"Mismatch channel in midrow parsing\"), !1;\n                    var i = this.channels[r - 1];\n                    return i.ccMIDROW(t), v.log(\"DEBUG\", \"MIDROW (\" + g([e, t]) + \")\"), !0;\n                  }\n\n                  return !1;\n                }\n              }, {\n                key: \"parsePAC\",\n                value: function value(e, t) {\n                  var r = null,\n                      i = null,\n                      a = !((17 > e || e > 23) && (25 > e || e > 31) || 64 > t || t > 127),\n                      n = !(16 !== e && 24 !== e || 64 > t || t > 95);\n                  if (!a && !n) return !1;\n                  if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, this.lastCmdB = null, !0;\n                  r = e > 23 ? 2 : 1, i = 64 > t || t > 95 ? 1 === r ? d[e] : h[e] : 1 === r ? u[e] : f[e];\n                  var s = this.interpretPAC(i, t),\n                      o = this.channels[r - 1];\n                  return o.setPAC(s), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0;\n                }\n              }, {\n                key: \"interpretPAC\",\n                value: function value(e, t) {\n                  var r = t,\n                      i = {\n                    color: null,\n                    italics: !1,\n                    indent: null,\n                    underline: !1,\n                    row: e\n                  };\n                  return r = t > 95 ? t - 96 : t - 64, i.underline = 1 === (1 & r), r > 13 ? r > 15 ? i.indent = 4 * Math.floor((r - 16) / 2) : (i.italics = !0, i.color = \"white\") : i.color = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\", \"white\"][Math.floor(r / 2)], i;\n                }\n              }, {\n                key: \"parseChars\",\n                value: function value(e, t) {\n                  var r = null,\n                      i = null,\n                      a = null;\n                  if (25 > e ? (r = 1, a = e) : (r = 2, a = e - 8), 17 > a || a > 19) 32 > e || e > 127 || (i = 0 === t ? [e] : [e, t]);else {\n                    var n = t;\n                    n = 17 === a ? t + 80 : 18 === a ? t + 112 : t + 144, v.log(\"INFO\", \"Special char '\" + s(n) + \"' in channel \" + r), i = [n];\n                  }\n\n                  if (i) {\n                    var o = g(i);\n                    v.log(\"DEBUG\", \"Char codes =  \" + o.join(\",\")), this.lastCmdA = null, this.lastCmdB = null;\n                  }\n\n                  return i;\n                }\n              }, {\n                key: \"parseBackgroundAttributes\",\n                value: function value(e, t) {\n                  var r,\n                      i,\n                      a,\n                      n,\n                      s = !(16 !== e && 24 !== e || 32 > t || t > 47),\n                      o = !(23 !== e && 31 !== e || 45 > t || t > 47);\n                  return !(!s && !o) && (r = {}, 16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), r.background = c[i], t % 2 === 1 && (r.background = r.background + \"_semi\")) : 45 === t ? r.background = \"transparent\" : (r.foreground = \"black\", 47 === t && (r.underline = !0)), a = 24 > e ? 1 : 2, n = this.channels[a - 1], n.setBkgData(r), this.lastCmdA = null, this.lastCmdB = null, !0);\n                }\n              }, {\n                key: \"reset\",\n                value: function value() {\n                  for (var e = 0; this.channels.length > e; e++) {\n                    this.channels[e] && this.channels[e].reset();\n                  }\n\n                  this.lastCmdA = null, this.lastCmdB = null;\n                }\n              }, {\n                key: \"cueSplitAtTime\",\n                value: function value(e) {\n                  for (var t = 0; this.channels.length > t; t++) {\n                    this.channels[t] && this.channels[t].cueSplitAtTime(e);\n                  }\n                }\n              }]), e;\n            }();\n\n            r.default = R;\n          }, {}],\n          43: [function (e, t, r) {\n            \"use strict\";\n\n            var i = {\n              newCue: function newCue(e, t, r, i) {\n                for (var a, n, s, o, l, u = window.VTTCue || window.TextTrackCue, d = 0; i.rows.length > d; d++) {\n                  if (a = i.rows[d], s = !0, o = 0, l = \"\", !a.isEmpty()) {\n                    for (var f = 0; a.chars.length > f; f++) {\n                      a.chars[f].uchar.match(/\\s/) && s ? o++ : (l += a.chars[f].uchar, s = !1);\n                    }\n\n                    a.cueStartTime = t, n = new u(t, r, l.trim()), 16 > o ? o++ : o--, n.line = navigator.userAgent.match(/Firefox\\//) ? d + 1 : d > 7 ? d - 2 : d + 1, n.align = \"left\", n.position = Math.max(0, Math.min(100, 100 * (o / 32) + (navigator.userAgent.match(/Firefox\\//) ? 50 : 0))), e.addCue(n);\n                  }\n                }\n              }\n            };\n            t.exports = i;\n          }, {}],\n          44: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e(t) {\n                i(this, e), this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = 0, this.totalWeight_ = 0;\n              }\n\n              return a(e, [{\n                key: \"sample\",\n                value: function value(e, t) {\n                  var r = Math.pow(this.alpha_, e);\n                  this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e;\n                }\n              }, {\n                key: \"getTotalWeight\",\n                value: function value() {\n                  return this.totalWeight_;\n                }\n              }, {\n                key: \"getEstimate\",\n                value: function value() {\n                  if (this.alpha_) {\n                    var e = 1 - Math.pow(this.alpha_, this.totalWeight_);\n                    return this.estimate_ / e;\n                  }\n\n                  return this.estimate_;\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          45: [function (e, t, r) {\n            \"use strict\";\n\n            function i() {}\n\n            function a(e, t) {\n              return t = \"[\" + e + \"] > \" + t;\n            }\n\n            function n(e) {\n              var t = self.console[e];\n              return t ? function () {\n                for (var r = arguments.length, i = Array(r), n = 0; r > n; n++) {\n                  i[n] = arguments[n];\n                }\n\n                i[0] && (i[0] = a(e, i[0])), t.apply(self.console, i);\n              } : i;\n            }\n\n            function s(e) {\n              for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; t > i; i++) {\n                r[i - 1] = arguments[i];\n              }\n\n              r.forEach(function (t) {\n                u[t] = e[t] ? e[t].bind(e) : n(t);\n              });\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n            var o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n              return typeof e;\n            } : function (e) {\n              return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n            },\n                l = {\n              trace: i,\n              debug: i,\n              log: i,\n              warn: i,\n              info: i,\n              error: i\n            },\n                u = l;\n            r.enableLogs = function (e) {\n              if (e === !0 || \"object\" === (void 0 === e ? \"undefined\" : o(e))) {\n                s(e, \"debug\", \"log\", \"info\", \"warn\", \"error\");\n\n                try {\n                  u.log();\n                } catch (e) {\n                  u = l;\n                }\n              } else u = l;\n            }, r.logger = u;\n          }, {}],\n          46: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = function () {\n              function e() {\n                i(this, e);\n              }\n\n              return a(e, null, [{\n                key: \"toString\",\n                value: function value(e) {\n                  for (var t = \"\", r = e.length, i = 0; r > i; i++) {\n                    t += \"[\" + e.start(i).toFixed(3) + \",\" + e.end(i).toFixed(3) + \"]\";\n                  }\n\n                  return t;\n                }\n              }]), e;\n            }();\n\n            r.default = n;\n          }, {}],\n          47: [function (e, t, r) {\n            \"use strict\";\n\n            function i(e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }\n\n            Object.defineProperty(r, \"__esModule\", {\n              value: !0\n            });\n\n            var a = function () {\n              function e(e, t) {\n                for (var r = 0; t.length > r; r++) {\n                  var i = t[r];\n                  i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n                }\n              }\n\n              return function (t, r, i) {\n                return r && e(t.prototype, r), i && e(t, i), t;\n              };\n            }(),\n                n = e(45),\n                s = function () {\n              function e(t) {\n                i(this, e), t && t.xhrSetup && (this.xhrSetup = t.xhrSetup);\n              }\n\n              return a(e, [{\n                key: \"destroy\",\n                value: function value() {\n                  this.abort(), this.loader = null;\n                }\n              }, {\n                key: \"abort\",\n                value: function value() {\n                  var e = this.loader;\n                  e && 4 !== e.readyState && (this.stats.aborted = !0, e.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null;\n                }\n              }, {\n                key: \"load\",\n                value: function value(e, t, r) {\n                  this.context = e, this.config = t, this.callbacks = r, this.stats = {\n                    trequest: performance.now(),\n                    retry: 0\n                  }, this.retryDelay = t.retryDelay, this.loadInternal();\n                }\n              }, {\n                key: \"loadInternal\",\n                value: function value() {\n                  var e,\n                      t = this.context;\n                  e = this.loader = \"undefined\" != typeof XDomainRequest ? new XDomainRequest() : new XMLHttpRequest(), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.open(\"GET\", t.url, !0), t.rangeEnd && e.setRequestHeader(\"Range\", \"bytes=\" + t.rangeStart + \"-\" + (t.rangeEnd - 1)), e.responseType = t.responseType;\n                  var r = this.stats;\n                  r.tfirst = 0, r.loaded = 0, this.xhrSetup && this.xhrSetup(e, t.url), this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), e.send();\n                }\n              }, {\n                key: \"readystatechange\",\n                value: function value(e) {\n                  var t = e.currentTarget,\n                      r = t.readyState,\n                      i = this.stats,\n                      a = this.context,\n                      s = this.config;\n\n                  if (!i.aborted && (window.clearTimeout(this.requestTimeout), r >= 2 && (0 === i.tfirst && (i.tfirst = Math.max(performance.now(), i.trequest), this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), s.timeout - (i.tfirst - i.trequest))), 4 === r))) {\n                    var o = t.status;\n\n                    if (o >= 200 && 300 > o) {\n                      i.tload = Math.max(i.tfirst, performance.now());\n                      var l = void 0,\n                          u = void 0;\n                      \"arraybuffer\" === a.responseType ? (l = t.response, u = l.byteLength) : (l = t.responseText, u = l.length), i.loaded = i.total = u;\n                      var d = {\n                        url: t.responseURL,\n                        data: l\n                      };\n                      this.callbacks.onSuccess(d, i, a);\n                    } else i.retry >= s.maxRetry || o >= 400 && 499 > o ? (n.logger.error(o + \" while loading \" + a.url), this.callbacks.onError({\n                      code: o,\n                      text: t.statusText\n                    }, a)) : (n.logger.warn(o + \" while loading \" + a.url + \", retrying in \" + this.retryDelay + \"...\"), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, s.maxRetryDelay), i.retry++);\n                  }\n                }\n              }, {\n                key: \"loadtimeout\",\n                value: function value() {\n                  n.logger.warn(\"timeout while loading \" + this.context.url), this.callbacks.onTimeout(this.stats, this.context);\n                }\n              }, {\n                key: \"loadprogress\",\n                value: function value(e) {\n                  var t = this.stats;\n                  t.loaded = e.loaded, e.lengthComputable && (t.total = e.total);\n                  var r = this.callbacks.onProgress;\n                  r && r(t, this.context, null);\n                }\n              }]), e;\n            }();\n\n            r.default = s;\n          }, {\n            45: 45\n          }]\n        }, {}, [33])(33);\n      });\n    },\n    31: function _(e, t, r) {\n      e.exports = r(34)();\n    },\n    32: function _(e, t, r) {\n      \"use strict\";\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          default: e\n        };\n      }\n\n      function a(e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      function n(e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n      }\n\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n\n      var o = Object.assign || function (e) {\n        for (var t = 1; arguments.length > t; t++) {\n          var r = arguments[t];\n\n          for (var i in r) {\n            Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);\n          }\n        }\n\n        return e;\n      },\n          l = function () {\n        function e(e, t) {\n          for (var r = 0; t.length > r; r++) {\n            var i = t[r];\n            i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n          }\n        }\n\n        return function (t, r, i) {\n          return r && e(t.prototype, r), i && e(t, i), t;\n        };\n      }(),\n          u = r(17),\n          d = i(u),\n          f = r(31),\n          h = i(f),\n          c = r(30),\n          v = i(c),\n          g = function (e) {\n        function t(e) {\n          a(this, t);\n          var r = n(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));\n          return r.state = {\n            playerId: Date.now()\n          }, r.hls = null, r;\n        }\n\n        return s(t, e), l(t, [{\n          key: \"componentDidUpdate\",\n          value: function value() {\n            this._initPlayer();\n          }\n        }, {\n          key: \"componentDidMount\",\n          value: function value() {\n            this._initPlayer();\n          }\n        }, {\n          key: \"componentWillUnmount\",\n          value: function value() {\n            var e = this.hls;\n            e && e.destroy();\n          }\n        }, {\n          key: \"_initPlayer\",\n          value: function value() {\n            this.hls && this.hls.destroy();\n            var e = this.props,\n                t = e.url,\n                r = e.autoplay,\n                i = e.hlsConfig,\n                a = this.refs.video,\n                n = new v.default(i);\n            n.loadSource(t), n.attachMedia(a), n.on(v.default.Events.MANIFEST_PARSED, function () {\n              r && a.play();\n            }), this.hls = n;\n          }\n        }, {\n          key: \"render\",\n          value: function value() {\n            var e = this.state.playerId,\n                t = this.props,\n                r = t.controls,\n                i = t.width,\n                a = t.height,\n                n = t.poster,\n                s = t.videoProps;\n            return d.default.createElement(\"div\", {\n              key: e,\n              className: \"player-area\"\n            }, d.default.createElement(\"video\", o({\n              ref: \"video\",\n              className: \"hls-player\",\n              id: \"react-hls-\" + e,\n              controls: r,\n              width: i,\n              height: a,\n              poster: n\n            }, s)));\n          }\n        }]), t;\n      }(d.default.Component);\n\n      g.propTypes = {\n        url: h.default.string.isRequired,\n        autoplay: h.default.bool,\n        hlsConfig: h.default.object,\n        controls: h.default.bool,\n        width: h.default.number,\n        height: h.default.number,\n        poster: h.default.string,\n        videoProps: h.default.object\n      }, g.defaultProps = {\n        autoplay: !1,\n        hlsConfig: {},\n        controls: !0,\n        width: 500,\n        height: 375\n      }, t.default = g;\n    },\n    34: function _(e, t, r) {\n      \"use strict\";\n\n      var i = r(6),\n          a = r(0),\n          n = r(24);\n\n      e.exports = function () {\n        function e(e, t, r, i, s, o) {\n          o !== n && a(!1, \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n        }\n\n        function t() {\n          return e;\n        }\n\n        e.isRequired = e;\n        var r = {\n          array: e,\n          bool: e,\n          func: e,\n          number: e,\n          object: e,\n          string: e,\n          symbol: e,\n          any: e,\n          arrayOf: t,\n          element: e,\n          instanceOf: t,\n          node: e,\n          objectOf: t,\n          oneOf: t,\n          oneOfType: t,\n          shape: t\n        };\n        return r.checkPropTypes = i, r.PropTypes = r, r;\n      };\n    },\n    6: function _(e, t, r) {\n      \"use strict\";\n\n      function i(e) {\n        return function () {\n          return e;\n        };\n      }\n\n      var a = function a() {};\n\n      a.thatReturns = i, a.thatReturnsFalse = i(!1), a.thatReturnsTrue = i(!0), a.thatReturnsNull = i(null), a.thatReturnsThis = function () {\n        return this;\n      }, a.thatReturnsArgument = function (e) {\n        return e;\n      }, e.exports = a;\n    }\n  });\n});","map":null,"metadata":{},"sourceType":"script"}